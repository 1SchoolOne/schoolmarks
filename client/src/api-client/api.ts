/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Assessment
 */
export interface Assessment {
    /**
     * 
     * @type {string}
     * @memberof Assessment
     */
    'id': string;
    /**
     * 
     * @type {Course}
     * @memberof Assessment
     */
    'course': Course;
    /**
     * 
     * @type {string}
     * @memberof Assessment
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Assessment
     */
    'max_value': string;
    /**
     * Pourcentage de la note finale
     * @type {string}
     * @memberof Assessment
     */
    'coef': string;
    /**
     * 
     * @type {string}
     * @memberof Assessment
     */
    'description'?: string | null;
    /**
     * 
     * @type {Class}
     * @memberof Assessment
     */
    'class_group': Class;
    /**
     * 
     * @type {Array<StudentGrade>}
     * @memberof Assessment
     */
    'student_grades': Array<StudentGrade>;
    /**
     * 
     * @type {string}
     * @memberof Assessment
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Assessment
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface AssessmentInput
 */
export interface AssessmentInput {
    /**
     * 
     * @type {string}
     * @memberof AssessmentInput
     */
    'course_id': string;
    /**
     * 
     * @type {string}
     * @memberof AssessmentInput
     */
    'class_id': string;
    /**
     * 
     * @type {string}
     * @memberof AssessmentInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AssessmentInput
     */
    'max_value': string;
    /**
     * 
     * @type {string}
     * @memberof AssessmentInput
     */
    'coef': string;
    /**
     * 
     * @type {string}
     * @memberof AssessmentInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<StudentGradeInput>}
     * @memberof AssessmentInput
     */
    'student_grades'?: Array<StudentGradeInput>;
}
/**
 * 
 * @export
 * @interface AssessmentWithoutGrades
 */
export interface AssessmentWithoutGrades {
    /**
     * 
     * @type {string}
     * @memberof AssessmentWithoutGrades
     */
    'id': string;
    /**
     * 
     * @type {Course}
     * @memberof AssessmentWithoutGrades
     */
    'course': Course;
    /**
     * 
     * @type {string}
     * @memberof AssessmentWithoutGrades
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AssessmentWithoutGrades
     */
    'max_value': string;
    /**
     * Pourcentage de la note finale
     * @type {string}
     * @memberof AssessmentWithoutGrades
     */
    'coef': string;
    /**
     * 
     * @type {string}
     * @memberof AssessmentWithoutGrades
     */
    'description'?: string | null;
    /**
     * 
     * @type {Class}
     * @memberof AssessmentWithoutGrades
     */
    'class_group': Class;
    /**
     * 
     * @type {string}
     * @memberof AssessmentWithoutGrades
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof AssessmentWithoutGrades
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface Attendance
 */
export interface Attendance {
    /**
     * 
     * @type {string}
     * @memberof Attendance
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Attendance
     */
    'class_session': string;
    /**
     * 
     * @type {number}
     * @memberof Attendance
     */
    'student': number;
    /**
     * 
     * @type {User}
     * @memberof Attendance
     */
    'student_detail': User;
    /**
     * 
     * @type {string}
     * @memberof Attendance
     */
    'checked_in_at': string;
    /**
     * 
     * @type {AttendanceStatusEnum}
     * @memberof Attendance
     */
    'status': AttendanceStatusEnum;
}


/**
 * * `present` - Présent * `late` - En retard * `absent` - Absent
 * @export
 * @enum {string}
 */

export const AttendanceStatusEnum = {
    Present: 'present',
    Late: 'late',
    Absent: 'absent'
} as const;

export type AttendanceStatusEnum = typeof AttendanceStatusEnum[keyof typeof AttendanceStatusEnum];


/**
 * 
 * @export
 * @interface BulkDeleteClass
 */
export interface BulkDeleteClass {
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkDeleteClass
     */
    'class_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface BulkDeleteClassResponse
 */
export interface BulkDeleteClassResponse {
    /**
     * 
     * @type {string}
     * @memberof BulkDeleteClassResponse
     */
    'detail': string;
    /**
     * Number of classes deleted
     * @type {number}
     * @memberof BulkDeleteClassResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface BulkDeleteCourse
 */
export interface BulkDeleteCourse {
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkDeleteCourse
     */
    'course_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface BulkDeleteCourseResponse
 */
export interface BulkDeleteCourseResponse {
    /**
     * 
     * @type {string}
     * @memberof BulkDeleteCourseResponse
     */
    'detail': string;
    /**
     * Number of classes deleted
     * @type {number}
     * @memberof BulkDeleteCourseResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface CheckinSession
 */
export interface CheckinSession {
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'class_session': string;
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'started_at': string;
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'closed_at': string;
    /**
     * 
     * @type {number}
     * @memberof CheckinSession
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface CheckinSessionInput
 */
export interface CheckinSessionInput {
    /**
     * 
     * @type {string}
     * @memberof CheckinSessionInput
     */
    'class_session': string;
    /**
     * 
     * @type {string}
     * @memberof CheckinSessionInput
     */
    'started_at': string;
    /**
     * 
     * @type {string}
     * @memberof CheckinSessionInput
     */
    'closed_at': string;
    /**
     * 
     * @type {number}
     * @memberof CheckinSessionInput
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof CheckinSessionInput
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface CheckinSessionRegister
 */
export interface CheckinSessionRegister {
    /**
     * 
     * @type {string}
     * @memberof CheckinSessionRegister
     */
    'totp_code': string;
}
/**
 * 
 * @export
 * @interface Class
 */
export interface Class {
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'id': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof Class
     */
    'students': Array<User>;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof Class
     */
    'year_of_graduation'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ClassCreateWithStudents
 */
export interface ClassCreateWithStudents {
    /**
     * 
     * @type {ClassInput}
     * @memberof ClassCreateWithStudents
     */
    'class_data': ClassInput;
    /**
     * Liste des étudiants à ajouter à la classe
     * @type {Array<number>}
     * @memberof ClassCreateWithStudents
     */
    'student_ids': Array<number>;
    /**
     * Liste des cours à assigner à la classe
     * @type {Array<string>}
     * @memberof ClassCreateWithStudents
     */
    'course_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface ClassCreateWithStudentsResponse
 */
export interface ClassCreateWithStudentsResponse {
    /**
     * 
     * @type {Class}
     * @memberof ClassCreateWithStudentsResponse
     */
    'class': Class;
    /**
     * 
     * @type {number}
     * @memberof ClassCreateWithStudentsResponse
     */
    'added_students': number;
    /**
     * 
     * @type {number}
     * @memberof ClassCreateWithStudentsResponse
     */
    'added_courses': number;
}
/**
 * 
 * @export
 * @interface ClassInput
 */
export interface ClassInput {
    /**
     * 
     * @type {string}
     * @memberof ClassInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClassInput
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof ClassInput
     */
    'year_of_graduation'?: number | null;
}
/**
 * 
 * @export
 * @interface ClassSession
 */
export interface ClassSession {
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'id': string;
    /**
     * 
     * @type {Course}
     * @memberof ClassSession
     */
    'course': Course;
    /**
     * 
     * @type {Class}
     * @memberof ClassSession
     */
    'class_group': Class;
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'end_time': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'room': string;
    /**
     * 
     * @type {CheckinSession}
     * @memberof ClassSession
     */
    'checkin_session': CheckinSession;
}
/**
 * 
 * @export
 * @interface ClassSessionInput
 */
export interface ClassSessionInput {
    /**
     * 
     * @type {string}
     * @memberof ClassSessionInput
     */
    'course_id': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSessionInput
     */
    'class_id': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSessionInput
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSessionInput
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSessionInput
     */
    'end_time': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSessionInput
     */
    'room': string;
}
/**
 * 
 * @export
 * @interface ClassStudent
 */
export interface ClassStudent {
    /**
     * 
     * @type {string}
     * @memberof ClassStudent
     */
    'id': string;
    /**
     * 
     * @type {Class}
     * @memberof ClassStudent
     */
    'class_group': Class;
    /**
     * 
     * @type {User}
     * @memberof ClassStudent
     */
    'student': User;
    /**
     * 
     * @type {string}
     * @memberof ClassStudent
     */
    'joined_at': string;
}
/**
 * 
 * @export
 * @interface Course
 */
export interface Course {
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'code': string;
    /**
     * 
     * @type {User}
     * @memberof Course
     */
    'professor': User;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface CourseInput
 */
export interface CourseInput {
    /**
     * 
     * @type {string}
     * @memberof CourseInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CourseInput
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof CourseInput
     */
    'professor_id'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateImportResponse
 */
export interface CreateImportResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateImportResponse
     */
    'import_id': string;
    /**
     * 
     * @type {Status7feEnum}
     * @memberof CreateImportResponse
     */
    'status': Status7feEnum;
}


/**
 * 
 * @export
 * @interface ImportStatus
 */
export interface ImportStatus {
    /**
     * 
     * @type {string}
     * @memberof ImportStatus
     */
    'import_id': string;
    /**
     * 
     * @type {TypeEnum}
     * @memberof ImportStatus
     */
    'type': TypeEnum;
    /**
     * 
     * @type {Status7feEnum}
     * @memberof ImportStatus
     */
    'status': Status7feEnum;
    /**
     * 
     * @type {number}
     * @memberof ImportStatus
     */
    'progress': number;
    /**
     * 
     * @type {string}
     * @memberof ImportStatus
     */
    'imported_by': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ImportStatus
     */
    'results': Array<object>;
    /**
     * 
     * @type {string}
     * @memberof ImportStatus
     */
    'error'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImportStatus
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ImportStatus
     */
    'finished_at': string;
    /**
     * 
     * @type {string}
     * @memberof ImportStatus
     */
    'started_at': string;
}


/**
 * 
 * @export
 * @interface PatchedCheckinSession
 */
export interface PatchedCheckinSession {
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'class_session'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'started_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'closed_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedCheckinSession
     */
    'created_by'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface PatchedClass
 */
export interface PatchedClass {
    /**
     * 
     * @type {string}
     * @memberof PatchedClass
     */
    'id'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedClass
     */
    'students'?: Array<User>;
    /**
     * 
     * @type {string}
     * @memberof PatchedClass
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClass
     */
    'code'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedClass
     */
    'year_of_graduation'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedClass
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClass
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedClassSession
 */
export interface PatchedClassSession {
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSession
     */
    'id'?: string;
    /**
     * 
     * @type {Course}
     * @memberof PatchedClassSession
     */
    'course'?: Course;
    /**
     * 
     * @type {Class}
     * @memberof PatchedClassSession
     */
    'class_group'?: Class;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSession
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSession
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSession
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSession
     */
    'room'?: string;
    /**
     * 
     * @type {CheckinSession}
     * @memberof PatchedClassSession
     */
    'checkin_session'?: CheckinSession;
}
/**
 * 
 * @export
 * @interface PatchedClassStudent
 */
export interface PatchedClassStudent {
    /**
     * 
     * @type {string}
     * @memberof PatchedClassStudent
     */
    'id'?: string;
    /**
     * 
     * @type {Class}
     * @memberof PatchedClassStudent
     */
    'class_group'?: Class;
    /**
     * 
     * @type {User}
     * @memberof PatchedClassStudent
     */
    'student'?: User;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassStudent
     */
    'joined_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedCourseInput
 */
export interface PatchedCourseInput {
    /**
     * 
     * @type {string}
     * @memberof PatchedCourseInput
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCourseInput
     */
    'code'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedCourseInput
     */
    'professor_id'?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedUserInput
 */
export interface PatchedUserInput {
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof PatchedUserInput
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserInput
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserInput
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserInput
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserInput
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserInput
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserInput
     */
    'has_changed_password'?: boolean;
    /**
     * 
     * @type {UserRoleEnum}
     * @memberof PatchedUserInput
     */
    'user_role'?: UserRoleEnum;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RoleEnum = {
    Admin: 'admin',
    Teacher: 'teacher',
    Student: 'student'
} as const;

export type RoleEnum = typeof RoleEnum[keyof typeof RoleEnum];


/**
 * * `processing` - processing * `completed` - completed * `failed` - failed
 * @export
 * @enum {string}
 */

export const Status7feEnum = {
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type Status7feEnum = typeof Status7feEnum[keyof typeof Status7feEnum];


/**
 * 
 * @export
 * @interface StudentGrade
 */
export interface StudentGrade {
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'id': string;
    /**
     * 
     * @type {AssessmentWithoutGrades}
     * @memberof StudentGrade
     */
    'assessment': AssessmentWithoutGrades;
    /**
     * 
     * @type {User}
     * @memberof StudentGrade
     */
    'student': User;
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'comment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface StudentGradeInput
 */
export interface StudentGradeInput {
    /**
     * 
     * @type {string}
     * @memberof StudentGradeInput
     */
    'grade_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StudentGradeInput
     */
    'student_id': number;
    /**
     * 
     * @type {string}
     * @memberof StudentGradeInput
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof StudentGradeInput
     */
    'comment': string;
}
/**
 * * `users` - users * `classes` - classes * `courses` - courses
 * @export
 * @enum {string}
 */

export const TypeEnum = {
    Users: 'users',
    Classes: 'classes',
    Courses: 'courses'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];


/**
 * 
 * @export
 * @interface UpdateClassCourses
 */
export interface UpdateClassCourses {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateClassCourses
     */
    'course_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateClassStudents
 */
export interface UpdateClassStudents {
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateClassStudents
     */
    'student_ids': Array<number>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'has_changed_password'?: boolean;
    /**
     * 
     * @type {RoleEnum}
     * @memberof User
     */
    'role': RoleEnum;
}


/**
 * 
 * @export
 * @interface UserInput
 */
export interface UserInput {
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof UserInput
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserInput
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInput
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInput
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserInput
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserInput
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserInput
     */
    'has_changed_password'?: boolean;
    /**
     * 
     * @type {UserRoleEnum}
     * @memberof UserInput
     */
    'user_role': UserRoleEnum;
}


/**
 * * `student` - student * `teacher` - teacher * `admin` - admin
 * @export
 * @enum {string}
 */

export const UserRoleEnum = {
    Student: 'student',
    Teacher: 'teacher',
    Admin: 'admin'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];



/**
 * AssessmentsApi - axios parameter creator
 * @export
 */
export const AssessmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AssessmentInput} assessmentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assessmentsCreate: async (assessmentInput: AssessmentInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assessmentInput' is not null or undefined
            assertParamExists('assessmentsCreate', 'assessmentInput', assessmentInput)
            const localVarPath = `/assessments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assessmentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this assessment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assessmentsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assessmentsDestroy', 'id', id)
            const localVarPath = `/assessments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [classId] 
         * @param {string} [courseId] 
         * @param {number} [month] Month (1-12)
         * @param {number} [year] Year (e.g., 2024)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assessmentsList: async (classId?: string, courseId?: string, month?: number, year?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assessments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required

            if (classId !== undefined) {
                localVarQueryParameter['class_id'] = classId;
            }

            if (courseId !== undefined) {
                localVarQueryParameter['course_id'] = courseId;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this assessment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assessmentsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assessmentsRetrieve', 'id', id)
            const localVarPath = `/assessments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing assessment with student grades
         * @param {string} id A UUID string identifying this assessment.
         * @param {AssessmentInput} assessmentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assessmentsUpdate: async (id: string, assessmentInput: AssessmentInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assessmentsUpdate', 'id', id)
            // verify required parameter 'assessmentInput' is not null or undefined
            assertParamExists('assessmentsUpdate', 'assessmentInput', assessmentInput)
            const localVarPath = `/assessments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assessmentInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssessmentsApi - functional programming interface
 * @export
 */
export const AssessmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssessmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AssessmentInput} assessmentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assessmentsCreate(assessmentInput: AssessmentInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assessment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assessmentsCreate(assessmentInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssessmentsApi.assessmentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this assessment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assessmentsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assessmentsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssessmentsApi.assessmentsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [classId] 
         * @param {string} [courseId] 
         * @param {number} [month] Month (1-12)
         * @param {number} [year] Year (e.g., 2024)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assessmentsList(classId?: string, courseId?: string, month?: number, year?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Assessment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assessmentsList(classId, courseId, month, year, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssessmentsApi.assessmentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this assessment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assessmentsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assessment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assessmentsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssessmentsApi.assessmentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing assessment with student grades
         * @param {string} id A UUID string identifying this assessment.
         * @param {AssessmentInput} assessmentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assessmentsUpdate(id: string, assessmentInput: AssessmentInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assessment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assessmentsUpdate(id, assessmentInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssessmentsApi.assessmentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssessmentsApi - factory interface
 * @export
 */
export const AssessmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssessmentsApiFp(configuration)
    return {
        /**
         * 
         * @param {AssessmentInput} assessmentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assessmentsCreate(assessmentInput: AssessmentInput, options?: RawAxiosRequestConfig): AxiosPromise<Assessment> {
            return localVarFp.assessmentsCreate(assessmentInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this assessment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assessmentsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.assessmentsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [classId] 
         * @param {string} [courseId] 
         * @param {number} [month] Month (1-12)
         * @param {number} [year] Year (e.g., 2024)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assessmentsList(classId?: string, courseId?: string, month?: number, year?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Assessment>> {
            return localVarFp.assessmentsList(classId, courseId, month, year, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this assessment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assessmentsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Assessment> {
            return localVarFp.assessmentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing assessment with student grades
         * @param {string} id A UUID string identifying this assessment.
         * @param {AssessmentInput} assessmentInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assessmentsUpdate(id: string, assessmentInput: AssessmentInput, options?: RawAxiosRequestConfig): AxiosPromise<Assessment> {
            return localVarFp.assessmentsUpdate(id, assessmentInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssessmentsApi - object-oriented interface
 * @export
 * @class AssessmentsApi
 * @extends {BaseAPI}
 */
export class AssessmentsApi extends BaseAPI {
    /**
     * 
     * @param {AssessmentInput} assessmentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssessmentsApi
     */
    public assessmentsCreate(assessmentInput: AssessmentInput, options?: RawAxiosRequestConfig) {
        return AssessmentsApiFp(this.configuration).assessmentsCreate(assessmentInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this assessment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssessmentsApi
     */
    public assessmentsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return AssessmentsApiFp(this.configuration).assessmentsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [classId] 
     * @param {string} [courseId] 
     * @param {number} [month] Month (1-12)
     * @param {number} [year] Year (e.g., 2024)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssessmentsApi
     */
    public assessmentsList(classId?: string, courseId?: string, month?: number, year?: number, options?: RawAxiosRequestConfig) {
        return AssessmentsApiFp(this.configuration).assessmentsList(classId, courseId, month, year, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this assessment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssessmentsApi
     */
    public assessmentsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return AssessmentsApiFp(this.configuration).assessmentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing assessment with student grades
     * @param {string} id A UUID string identifying this assessment.
     * @param {AssessmentInput} assessmentInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssessmentsApi
     */
    public assessmentsUpdate(id: string, assessmentInput: AssessmentInput, options?: RawAxiosRequestConfig) {
        return AssessmentsApiFp(this.configuration).assessmentsUpdate(id, assessmentInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AttendancesApi - axios parameter creator
 * @export
 */
export const AttendancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendancesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attendances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendancesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attendancesRetrieve', 'id', id)
            const localVarPath = `/attendances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttendancesApi - functional programming interface
 * @export
 */
export const AttendancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttendancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendancesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attendance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendancesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendancesApi.attendancesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendancesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attendance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendancesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendancesApi.attendancesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AttendancesApi - factory interface
 * @export
 */
export const AttendancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttendancesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendancesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Attendance>> {
            return localVarFp.attendancesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendancesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Attendance> {
            return localVarFp.attendancesRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttendancesApi - object-oriented interface
 * @export
 * @class AttendancesApi
 * @extends {BaseAPI}
 */
export class AttendancesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendancesApi
     */
    public attendancesList(options?: RawAxiosRequestConfig) {
        return AttendancesApiFp(this.configuration).attendancesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this attendance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendancesApi
     */
    public attendancesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return AttendancesApiFp(this.configuration).attendancesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CheckinSessionsApi - axios parameter creator
 * @export
 */
export const CheckinSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CheckinSessionInput} checkinSessionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsCreate: async (checkinSessionInput: CheckinSessionInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkinSessionInput' is not null or undefined
            assertParamExists('checkinSessionsCreate', 'checkinSessionInput', checkinSessionInput)
            const localVarPath = `/checkin_sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkinSessionInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsDestroy', 'id', id)
            const localVarPath = `/checkin_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/checkin_sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {PatchedCheckinSession} [patchedCheckinSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsPartialUpdate: async (id: string, patchedCheckinSession?: PatchedCheckinSession, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsPartialUpdate', 'id', id)
            const localVarPath = `/checkin_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCheckinSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {CheckinSessionRegister} checkinSessionRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsRegisterCreate: async (id: string, checkinSessionRegister: CheckinSessionRegister, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsRegisterCreate', 'id', id)
            // verify required parameter 'checkinSessionRegister' is not null or undefined
            assertParamExists('checkinSessionsRegisterCreate', 'checkinSessionRegister', checkinSessionRegister)
            const localVarPath = `/checkin_sessions/{id}/register/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkinSessionRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsRetrieve', 'id', id)
            const localVarPath = `/checkin_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsTotpRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsTotpRetrieve', 'id', id)
            const localVarPath = `/checkin_sessions/{id}/totp/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {CheckinSession} checkinSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsUpdate: async (id: string, checkinSession: CheckinSession, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsUpdate', 'id', id)
            // verify required parameter 'checkinSession' is not null or undefined
            assertParamExists('checkinSessionsUpdate', 'checkinSession', checkinSession)
            const localVarPath = `/checkin_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkinSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckinSessionsApi - functional programming interface
 * @export
 */
export const CheckinSessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckinSessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CheckinSessionInput} checkinSessionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsCreate(checkinSessionInput: CheckinSessionInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsCreate(checkinSessionInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CheckinSession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {PatchedCheckinSession} [patchedCheckinSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsPartialUpdate(id: string, patchedCheckinSession?: PatchedCheckinSession, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsPartialUpdate(id, patchedCheckinSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {CheckinSessionRegister} checkinSessionRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsRegisterCreate(id: string, checkinSessionRegister: CheckinSessionRegister, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsRegisterCreate(id, checkinSessionRegister, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsRegisterCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsTotpRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsTotpRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsTotpRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {CheckinSession} checkinSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsUpdate(id: string, checkinSession: CheckinSession, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsUpdate(id, checkinSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CheckinSessionsApi - factory interface
 * @export
 */
export const CheckinSessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckinSessionsApiFp(configuration)
    return {
        /**
         * 
         * @param {CheckinSessionInput} checkinSessionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsCreate(checkinSessionInput: CheckinSessionInput, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsCreate(checkinSessionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.checkinSessionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CheckinSession>> {
            return localVarFp.checkinSessionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {PatchedCheckinSession} [patchedCheckinSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsPartialUpdate(id: string, patchedCheckinSession?: PatchedCheckinSession, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsPartialUpdate(id, patchedCheckinSession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {CheckinSessionRegister} checkinSessionRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsRegisterCreate(id: string, checkinSessionRegister: CheckinSessionRegister, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsRegisterCreate(id, checkinSessionRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsTotpRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsTotpRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {CheckinSession} checkinSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsUpdate(id: string, checkinSession: CheckinSession, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsUpdate(id, checkinSession, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckinSessionsApi - object-oriented interface
 * @export
 * @class CheckinSessionsApi
 * @extends {BaseAPI}
 */
export class CheckinSessionsApi extends BaseAPI {
    /**
     * 
     * @param {CheckinSessionInput} checkinSessionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsCreate(checkinSessionInput: CheckinSessionInput, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsCreate(checkinSessionInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsList(options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {PatchedCheckinSession} [patchedCheckinSession] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsPartialUpdate(id: string, patchedCheckinSession?: PatchedCheckinSession, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsPartialUpdate(id, patchedCheckinSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {CheckinSessionRegister} checkinSessionRegister 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsRegisterCreate(id: string, checkinSessionRegister: CheckinSessionRegister, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsRegisterCreate(id, checkinSessionRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsTotpRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsTotpRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {CheckinSession} checkinSession 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsUpdate(id: string, checkinSession: CheckinSession, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsUpdate(id, checkinSession, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClassSessionsApi - axios parameter creator
 * @export
 */
export const ClassSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ClassSessionInput} classSessionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsCreate: async (classSessionInput: ClassSessionInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classSessionInput' is not null or undefined
            assertParamExists('classSessionsCreate', 'classSessionInput', classSessionInput)
            const localVarPath = `/class_sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classSessionInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classSessionsDestroy', 'id', id)
            const localVarPath = `/class_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [courseCode] 
         * @param {string} [courseId] 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsList: async (courseCode?: string, courseId?: string, endDate?: string, startDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/class_sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required

            if (courseCode !== undefined) {
                localVarQueryParameter['course_code'] = courseCode;
            }

            if (courseId !== undefined) {
                localVarQueryParameter['course_id'] = courseId;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {PatchedClassSession} [patchedClassSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsPartialUpdate: async (id: string, patchedClassSession?: PatchedClassSession, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classSessionsPartialUpdate', 'id', id)
            const localVarPath = `/class_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedClassSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classSessionsRetrieve', 'id', id)
            const localVarPath = `/class_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {ClassSessionInput} classSessionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsUpdate: async (id: string, classSessionInput: ClassSessionInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classSessionsUpdate', 'id', id)
            // verify required parameter 'classSessionInput' is not null or undefined
            assertParamExists('classSessionsUpdate', 'classSessionInput', classSessionInput)
            const localVarPath = `/class_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classSessionInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassSessionsApi - functional programming interface
 * @export
 */
export const ClassSessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassSessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ClassSessionInput} classSessionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsCreate(classSessionInput: ClassSessionInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSessionInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsCreate(classSessionInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [courseCode] 
         * @param {string} [courseId] 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsList(courseCode?: string, courseId?: string, endDate?: string, startDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassSession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsList(courseCode, courseId, endDate, startDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {PatchedClassSession} [patchedClassSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsPartialUpdate(id: string, patchedClassSession?: PatchedClassSession, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsPartialUpdate(id, patchedClassSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {ClassSessionInput} classSessionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsUpdate(id: string, classSessionInput: ClassSessionInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSessionInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsUpdate(id, classSessionInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClassSessionsApi - factory interface
 * @export
 */
export const ClassSessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassSessionsApiFp(configuration)
    return {
        /**
         * 
         * @param {ClassSessionInput} classSessionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsCreate(classSessionInput: ClassSessionInput, options?: RawAxiosRequestConfig): AxiosPromise<ClassSessionInput> {
            return localVarFp.classSessionsCreate(classSessionInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.classSessionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [courseCode] 
         * @param {string} [courseId] 
         * @param {string} [endDate] 
         * @param {string} [startDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsList(courseCode?: string, courseId?: string, endDate?: string, startDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ClassSession>> {
            return localVarFp.classSessionsList(courseCode, courseId, endDate, startDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {PatchedClassSession} [patchedClassSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsPartialUpdate(id: string, patchedClassSession?: PatchedClassSession, options?: RawAxiosRequestConfig): AxiosPromise<ClassSession> {
            return localVarFp.classSessionsPartialUpdate(id, patchedClassSession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ClassSession> {
            return localVarFp.classSessionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {ClassSessionInput} classSessionInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsUpdate(id: string, classSessionInput: ClassSessionInput, options?: RawAxiosRequestConfig): AxiosPromise<ClassSessionInput> {
            return localVarFp.classSessionsUpdate(id, classSessionInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassSessionsApi - object-oriented interface
 * @export
 * @class ClassSessionsApi
 * @extends {BaseAPI}
 */
export class ClassSessionsApi extends BaseAPI {
    /**
     * 
     * @param {ClassSessionInput} classSessionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsCreate(classSessionInput: ClassSessionInput, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsCreate(classSessionInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [courseCode] 
     * @param {string} [courseId] 
     * @param {string} [endDate] 
     * @param {string} [startDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsList(courseCode?: string, courseId?: string, endDate?: string, startDate?: string, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsList(courseCode, courseId, endDate, startDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class session.
     * @param {PatchedClassSession} [patchedClassSession] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsPartialUpdate(id: string, patchedClassSession?: PatchedClassSession, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsPartialUpdate(id, patchedClassSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class session.
     * @param {ClassSessionInput} classSessionInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsUpdate(id: string, classSessionInput: ClassSessionInput, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsUpdate(id, classSessionInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClassStudentsApi - axios parameter creator
 * @export
 */
export const ClassStudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ClassStudent} [classStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsCreate: async (classStudent?: ClassStudent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/class_students/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classStudent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classStudentsDestroy', 'id', id)
            const localVarPath = `/class_students/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/class_students/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {PatchedClassStudent} [patchedClassStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsPartialUpdate: async (id: string, patchedClassStudent?: PatchedClassStudent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classStudentsPartialUpdate', 'id', id)
            const localVarPath = `/class_students/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedClassStudent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classStudentsRetrieve', 'id', id)
            const localVarPath = `/class_students/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {ClassStudent} [classStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsUpdate: async (id: string, classStudent?: ClassStudent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classStudentsUpdate', 'id', id)
            const localVarPath = `/class_students/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classStudent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassStudentsApi - functional programming interface
 * @export
 */
export const ClassStudentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassStudentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ClassStudent} [classStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsCreate(classStudent?: ClassStudent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsCreate(classStudent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassStudent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {PatchedClassStudent} [patchedClassStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsPartialUpdate(id: string, patchedClassStudent?: PatchedClassStudent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsPartialUpdate(id, patchedClassStudent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {ClassStudent} [classStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsUpdate(id: string, classStudent?: ClassStudent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsUpdate(id, classStudent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClassStudentsApi - factory interface
 * @export
 */
export const ClassStudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassStudentsApiFp(configuration)
    return {
        /**
         * 
         * @param {ClassStudent} [classStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsCreate(classStudent?: ClassStudent, options?: RawAxiosRequestConfig): AxiosPromise<ClassStudent> {
            return localVarFp.classStudentsCreate(classStudent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.classStudentsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ClassStudent>> {
            return localVarFp.classStudentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {PatchedClassStudent} [patchedClassStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsPartialUpdate(id: string, patchedClassStudent?: PatchedClassStudent, options?: RawAxiosRequestConfig): AxiosPromise<ClassStudent> {
            return localVarFp.classStudentsPartialUpdate(id, patchedClassStudent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ClassStudent> {
            return localVarFp.classStudentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this Class Membership.
         * @param {ClassStudent} [classStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsUpdate(id: string, classStudent?: ClassStudent, options?: RawAxiosRequestConfig): AxiosPromise<ClassStudent> {
            return localVarFp.classStudentsUpdate(id, classStudent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassStudentsApi - object-oriented interface
 * @export
 * @class ClassStudentsApi
 * @extends {BaseAPI}
 */
export class ClassStudentsApi extends BaseAPI {
    /**
     * 
     * @param {ClassStudent} [classStudent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsCreate(classStudent?: ClassStudent, options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsCreate(classStudent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this Class Membership.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsList(options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this Class Membership.
     * @param {PatchedClassStudent} [patchedClassStudent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsPartialUpdate(id: string, patchedClassStudent?: PatchedClassStudent, options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsPartialUpdate(id, patchedClassStudent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this Class Membership.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this Class Membership.
     * @param {ClassStudent} [classStudent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsUpdate(id: string, classStudent?: ClassStudent, options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsUpdate(id, classStudent, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClassesApi - axios parameter creator
 * @export
 */
export const ClassesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BulkDeleteClass} bulkDeleteClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesBulkDeleteCreate: async (bulkDeleteClass: BulkDeleteClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkDeleteClass' is not null or undefined
            assertParamExists('classesBulkDeleteCreate', 'bulkDeleteClass', bulkDeleteClass)
            const localVarPath = `/classes/bulk_delete/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDeleteClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all courses this class attends to
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesCoursesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesCoursesRetrieve', 'id', id)
            const localVarPath = `/classes/{id}/courses/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClassInput} classInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesCreate: async (classInput: ClassInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classInput' is not null or undefined
            assertParamExists('classesCreate', 'classInput', classInput)
            const localVarPath = `/classes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crée une classe et ajouter les étudiants en une opération
         * @param {ClassCreateWithStudents} classCreateWithStudents 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesCreateWithStudentsCreate: async (classCreateWithStudents: ClassCreateWithStudents, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classCreateWithStudents' is not null or undefined
            assertParamExists('classesCreateWithStudentsCreate', 'classCreateWithStudents', classCreateWithStudents)
            const localVarPath = `/classes/create_with_students/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classCreateWithStudents, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesDestroy', 'id', id)
            const localVarPath = `/classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [code] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesList: async (code?: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/classes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {PatchedClass} [patchedClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesPartialUpdate: async (id: string, patchedClass?: PatchedClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesPartialUpdate', 'id', id)
            const localVarPath = `/classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesRetrieve', 'id', id)
            const localVarPath = `/classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all students in this class
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesStudentsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesStudentsRetrieve', 'id', id)
            const localVarPath = `/classes/{id}/students/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdate: async (id: string, _class: Class, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesUpdate', 'id', id)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('classesUpdate', '_class', _class)
            const localVarPath = `/classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_class, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {UpdateClassCourses} updateClassCourses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdateCoursesCreate: async (id: string, updateClassCourses: UpdateClassCourses, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesUpdateCoursesCreate', 'id', id)
            // verify required parameter 'updateClassCourses' is not null or undefined
            assertParamExists('classesUpdateCoursesCreate', 'updateClassCourses', updateClassCourses)
            const localVarPath = `/classes/{id}/update_courses/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateClassCourses, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Met à jour la liste des étudiants d\'une classe.
         * @param {string} id A UUID string identifying this class.
         * @param {UpdateClassStudents} updateClassStudents 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdateStudentsCreate: async (id: string, updateClassStudents: UpdateClassStudents, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesUpdateStudentsCreate', 'id', id)
            // verify required parameter 'updateClassStudents' is not null or undefined
            assertParamExists('classesUpdateStudentsCreate', 'updateClassStudents', updateClassStudents)
            const localVarPath = `/classes/{id}/update_students/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateClassStudents, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassesApi - functional programming interface
 * @export
 */
export const ClassesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BulkDeleteClass} bulkDeleteClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesBulkDeleteCreate(bulkDeleteClass: BulkDeleteClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkDeleteClassResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesBulkDeleteCreate(bulkDeleteClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesBulkDeleteCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all courses this class attends to
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesCoursesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesCoursesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesCoursesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ClassInput} classInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesCreate(classInput: ClassInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesCreate(classInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crée une classe et ajouter les étudiants en une opération
         * @param {ClassCreateWithStudents} classCreateWithStudents 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesCreateWithStudentsCreate(classCreateWithStudents: ClassCreateWithStudents, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassCreateWithStudentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesCreateWithStudentsCreate(classCreateWithStudents, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesCreateWithStudentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [code] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesList(code?: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Class>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesList(code, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {PatchedClass} [patchedClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesPartialUpdate(id: string, patchedClass?: PatchedClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesPartialUpdate(id, patchedClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all students in this class
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesStudentsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesStudentsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesStudentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesUpdate(id, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {UpdateClassCourses} updateClassCourses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesUpdateCoursesCreate(id: string, updateClassCourses: UpdateClassCourses, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesUpdateCoursesCreate(id, updateClassCourses, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesUpdateCoursesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Met à jour la liste des étudiants d\'une classe.
         * @param {string} id A UUID string identifying this class.
         * @param {UpdateClassStudents} updateClassStudents 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesUpdateStudentsCreate(id: string, updateClassStudents: UpdateClassStudents, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesUpdateStudentsCreate(id, updateClassStudents, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesUpdateStudentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClassesApi - factory interface
 * @export
 */
export const ClassesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassesApiFp(configuration)
    return {
        /**
         * 
         * @param {BulkDeleteClass} bulkDeleteClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesBulkDeleteCreate(bulkDeleteClass: BulkDeleteClass, options?: RawAxiosRequestConfig): AxiosPromise<BulkDeleteClassResponse> {
            return localVarFp.classesBulkDeleteCreate(bulkDeleteClass, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all courses this class attends to
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesCoursesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Course>> {
            return localVarFp.classesCoursesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClassInput} classInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesCreate(classInput: ClassInput, options?: RawAxiosRequestConfig): AxiosPromise<ClassInput> {
            return localVarFp.classesCreate(classInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Crée une classe et ajouter les étudiants en une opération
         * @param {ClassCreateWithStudents} classCreateWithStudents 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesCreateWithStudentsCreate(classCreateWithStudents: ClassCreateWithStudents, options?: RawAxiosRequestConfig): AxiosPromise<ClassCreateWithStudentsResponse> {
            return localVarFp.classesCreateWithStudentsCreate(classCreateWithStudents, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.classesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [code] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesList(code?: string, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Class>> {
            return localVarFp.classesList(code, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {PatchedClass} [patchedClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesPartialUpdate(id: string, patchedClass?: PatchedClass, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesPartialUpdate(id, patchedClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all students in this class
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesStudentsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.classesStudentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesUpdate(id, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {UpdateClassCourses} updateClassCourses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdateCoursesCreate(id: string, updateClassCourses: UpdateClassCourses, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesUpdateCoursesCreate(id, updateClassCourses, options).then((request) => request(axios, basePath));
        },
        /**
         * Met à jour la liste des étudiants d\'une classe.
         * @param {string} id A UUID string identifying this class.
         * @param {UpdateClassStudents} updateClassStudents 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdateStudentsCreate(id: string, updateClassStudents: UpdateClassStudents, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesUpdateStudentsCreate(id, updateClassStudents, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassesApi - object-oriented interface
 * @export
 * @class ClassesApi
 * @extends {BaseAPI}
 */
export class ClassesApi extends BaseAPI {
    /**
     * 
     * @param {BulkDeleteClass} bulkDeleteClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesBulkDeleteCreate(bulkDeleteClass: BulkDeleteClass, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesBulkDeleteCreate(bulkDeleteClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all courses this class attends to
     * @param {string} id A UUID string identifying this class.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesCoursesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesCoursesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClassInput} classInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesCreate(classInput: ClassInput, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesCreate(classInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crée une classe et ajouter les étudiants en une opération
     * @param {ClassCreateWithStudents} classCreateWithStudents 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesCreateWithStudentsCreate(classCreateWithStudents: ClassCreateWithStudents, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesCreateWithStudentsCreate(classCreateWithStudents, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [code] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesList(code?: string, name?: string, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesList(code, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class.
     * @param {PatchedClass} [patchedClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesPartialUpdate(id: string, patchedClass?: PatchedClass, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesPartialUpdate(id, patchedClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all students in this class
     * @param {string} id A UUID string identifying this class.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesStudentsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesStudentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class.
     * @param {Class} _class 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesUpdate(id, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class.
     * @param {UpdateClassCourses} updateClassCourses 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesUpdateCoursesCreate(id: string, updateClassCourses: UpdateClassCourses, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesUpdateCoursesCreate(id, updateClassCourses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Met à jour la liste des étudiants d\'une classe.
     * @param {string} id A UUID string identifying this class.
     * @param {UpdateClassStudents} updateClassStudents 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesUpdateStudentsCreate(id: string, updateClassStudents: UpdateClassStudents, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesUpdateStudentsCreate(id, updateClassStudents, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BulkDeleteCourse} bulkDeleteCourse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesBulkDeleteCreate: async (bulkDeleteCourse: BulkDeleteCourse, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkDeleteCourse' is not null or undefined
            assertParamExists('coursesBulkDeleteCreate', 'bulkDeleteCourse', bulkDeleteCourse)
            const localVarPath = `/courses/bulk_delete/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDeleteCourse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CourseInput} courseInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesCreate: async (courseInput: CourseInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseInput' is not null or undefined
            assertParamExists('coursesCreate', 'courseInput', courseInput)
            const localVarPath = `/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coursesDestroy', 'id', id)
            const localVarPath = `/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [classId] 
         * @param {string} [code] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesList: async (classId?: string, code?: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required

            if (classId !== undefined) {
                localVarQueryParameter['class_id'] = classId;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {PatchedCourseInput} [patchedCourseInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesPartialUpdate: async (id: string, patchedCourseInput?: PatchedCourseInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coursesPartialUpdate', 'id', id)
            const localVarPath = `/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCourseInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coursesRetrieve', 'id', id)
            const localVarPath = `/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {CourseInput} courseInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesUpdate: async (id: string, courseInput: CourseInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coursesUpdate', 'id', id)
            // verify required parameter 'courseInput' is not null or undefined
            assertParamExists('coursesUpdate', 'courseInput', courseInput)
            const localVarPath = `/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BulkDeleteCourse} bulkDeleteCourse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesBulkDeleteCreate(bulkDeleteCourse: BulkDeleteCourse, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkDeleteCourseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesBulkDeleteCreate(bulkDeleteCourse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesBulkDeleteCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CourseInput} courseInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesCreate(courseInput: CourseInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesCreate(courseInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [classId] 
         * @param {string} [code] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesList(classId?: string, code?: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesList(classId, code, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {PatchedCourseInput} [patchedCourseInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesPartialUpdate(id: string, patchedCourseInput?: PatchedCourseInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesPartialUpdate(id, patchedCourseInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {CourseInput} courseInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesUpdate(id: string, courseInput: CourseInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesUpdate(id, courseInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesApiFp(configuration)
    return {
        /**
         * 
         * @param {BulkDeleteCourse} bulkDeleteCourse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesBulkDeleteCreate(bulkDeleteCourse: BulkDeleteCourse, options?: RawAxiosRequestConfig): AxiosPromise<BulkDeleteCourseResponse> {
            return localVarFp.coursesBulkDeleteCreate(bulkDeleteCourse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CourseInput} courseInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesCreate(courseInput: CourseInput, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.coursesCreate(courseInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coursesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [classId] 
         * @param {string} [code] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesList(classId?: string, code?: string, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Course>> {
            return localVarFp.coursesList(classId, code, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {PatchedCourseInput} [patchedCourseInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesPartialUpdate(id: string, patchedCourseInput?: PatchedCourseInput, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.coursesPartialUpdate(id, patchedCourseInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.coursesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {CourseInput} courseInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesUpdate(id: string, courseInput: CourseInput, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.coursesUpdate(id, courseInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
    /**
     * 
     * @param {BulkDeleteCourse} bulkDeleteCourse 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesBulkDeleteCreate(bulkDeleteCourse: BulkDeleteCourse, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesBulkDeleteCreate(bulkDeleteCourse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CourseInput} courseInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesCreate(courseInput: CourseInput, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesCreate(courseInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [classId] 
     * @param {string} [code] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesList(classId?: string, code?: string, name?: string, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesList(classId, code, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course.
     * @param {PatchedCourseInput} [patchedCourseInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesPartialUpdate(id: string, patchedCourseInput?: PatchedCourseInput, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesPartialUpdate(id, patchedCourseInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course.
     * @param {CourseInput} courseInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesUpdate(id: string, courseInput: CourseInput, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesUpdate(id, courseInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImportApi - axios parameter creator
 * @export
 */
export const ImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new class import
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importClassesCreate: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/classes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication CsrfExemptSessionAuthentication required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves class import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importClassesRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/classes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new course import
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCoursesCreate: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication CsrfExemptSessionAuthentication required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves course import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCoursesRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importRetrieve: async (importId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            assertParamExists('importRetrieve', 'importId', importId)
            const localVarPath = `/import/{import_id}/`
                .replace(`{${"import_id"}}`, encodeURIComponent(String(importId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user import
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsersCreate: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication CsrfExemptSessionAuthentication required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves user import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsersRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportApi - functional programming interface
 * @export
 */
export const ImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new class import
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importClassesCreate(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importClassesCreate(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importClassesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves class import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importClassesRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importClassesRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importClassesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new course import
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCoursesCreate(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCoursesCreate(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importCoursesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves course import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCoursesRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCoursesRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importCoursesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importRetrieve(importId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importRetrieve(importId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user import
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUsersCreate(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUsersCreate(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importUsersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves user import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUsersRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUsersRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importUsersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImportApi - factory interface
 * @export
 */
export const ImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportApiFp(configuration)
    return {
        /**
         * Creates a new class import
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importClassesCreate(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<CreateImportResponse> {
            return localVarFp.importClassesCreate(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves class import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importClassesRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
            return localVarFp.importClassesRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new course import
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCoursesCreate(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<CreateImportResponse> {
            return localVarFp.importCoursesCreate(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves course import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCoursesRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
            return localVarFp.importCoursesRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importRetrieve(importId: string, options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
            return localVarFp.importRetrieve(importId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user import
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsersCreate(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<CreateImportResponse> {
            return localVarFp.importUsersCreate(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves user import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsersRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
            return localVarFp.importUsersRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
export class ImportApi extends BaseAPI {
    /**
     * Creates a new class import
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importClassesCreate(file?: File, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importClassesCreate(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves class import information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importClassesRetrieve(options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importClassesRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new course import
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importCoursesCreate(file?: File, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importCoursesCreate(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves course import information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importCoursesRetrieve(options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importCoursesRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} importId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importRetrieve(importId: string, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importRetrieve(importId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user import
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importUsersCreate(file?: File, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importUsersCreate(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves user import information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importUsersRetrieve(options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importUsersRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(format, lang, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemaApi.schemaRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.schemaRetrieve(format, lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {SchemaRetrieveFormatEnum} [format] 
     * @param {SchemaRetrieveLangEnum} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaRetrieve(format, lang, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SchemaRetrieveFormatEnum = {
    Json: 'json',
    Yaml: 'yaml'
} as const;
export type SchemaRetrieveFormatEnum = typeof SchemaRetrieveFormatEnum[keyof typeof SchemaRetrieveFormatEnum];
/**
 * @export
 */
export const SchemaRetrieveLangEnum = {
    Af: 'af',
    Ar: 'ar',
    ArDz: 'ar-dz',
    Ast: 'ast',
    Az: 'az',
    Be: 'be',
    Bg: 'bg',
    Bn: 'bn',
    Br: 'br',
    Bs: 'bs',
    Ca: 'ca',
    Ckb: 'ckb',
    Cs: 'cs',
    Cy: 'cy',
    Da: 'da',
    De: 'de',
    Dsb: 'dsb',
    El: 'el',
    En: 'en',
    EnAu: 'en-au',
    EnGb: 'en-gb',
    Eo: 'eo',
    Es: 'es',
    EsAr: 'es-ar',
    EsCo: 'es-co',
    EsMx: 'es-mx',
    EsNi: 'es-ni',
    EsVe: 'es-ve',
    Et: 'et',
    Eu: 'eu',
    Fa: 'fa',
    Fi: 'fi',
    Fr: 'fr',
    Fy: 'fy',
    Ga: 'ga',
    Gd: 'gd',
    Gl: 'gl',
    He: 'he',
    Hi: 'hi',
    Hr: 'hr',
    Hsb: 'hsb',
    Hu: 'hu',
    Hy: 'hy',
    Ia: 'ia',
    Id: 'id',
    Ig: 'ig',
    Io: 'io',
    Is: 'is',
    It: 'it',
    Ja: 'ja',
    Ka: 'ka',
    Kab: 'kab',
    Kk: 'kk',
    Km: 'km',
    Kn: 'kn',
    Ko: 'ko',
    Ky: 'ky',
    Lb: 'lb',
    Lt: 'lt',
    Lv: 'lv',
    Mk: 'mk',
    Ml: 'ml',
    Mn: 'mn',
    Mr: 'mr',
    Ms: 'ms',
    My: 'my',
    Nb: 'nb',
    Ne: 'ne',
    Nl: 'nl',
    Nn: 'nn',
    Os: 'os',
    Pa: 'pa',
    Pl: 'pl',
    Pt: 'pt',
    PtBr: 'pt-br',
    Ro: 'ro',
    Ru: 'ru',
    Sk: 'sk',
    Sl: 'sl',
    Sq: 'sq',
    Sr: 'sr',
    SrLatn: 'sr-latn',
    Sv: 'sv',
    Sw: 'sw',
    Ta: 'ta',
    Te: 'te',
    Tg: 'tg',
    Th: 'th',
    Tk: 'tk',
    Tr: 'tr',
    Tt: 'tt',
    Udm: 'udm',
    Ug: 'ug',
    Uk: 'uk',
    Ur: 'ur',
    Uz: 'uz',
    Vi: 'vi',
    ZhHans: 'zh-hans',
    ZhHant: 'zh-hant'
} as const;
export type SchemaRetrieveLangEnum = typeof SchemaRetrieveLangEnum[keyof typeof SchemaRetrieveLangEnum];


/**
 * StudentGradesApi - axios parameter creator
 * @export
 */
export const StudentGradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/student_grades/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studentGradesRetrieve', 'id', id)
            const localVarPath = `/student_grades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentGradesApi - functional programming interface
 * @export
 */
export const StudentGradesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentGradesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentGradesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudentGrade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentGradesApi.studentGradesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentGradesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentGradesApi.studentGradesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudentGradesApi - factory interface
 * @export
 */
export const StudentGradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentGradesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<StudentGrade>> {
            return localVarFp.studentGradesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StudentGrade> {
            return localVarFp.studentGradesRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentGradesApi - object-oriented interface
 * @export
 * @class StudentGradesApi
 * @extends {BaseAPI}
 */
export class StudentGradesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentGradesApi
     */
    public studentGradesList(options?: RawAxiosRequestConfig) {
        return StudentGradesApiFp(this.configuration).studentGradesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this student grade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentGradesApi
     */
    public studentGradesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StudentGradesApiFp(this.configuration).studentGradesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserInput} userInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: async (userInput: UserInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInput' is not null or undefined
            assertParamExists('usersCreate', 'userInput', userInput)
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDestroy', 'id', id)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [role] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (role?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserInput} [patchedUserInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (id: number, patchedUserInput?: PatchedUserInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPartialUpdate', 'id', id)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRetrieve', 'id', id)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserInput} userInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: number, userInput: UserInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            // verify required parameter 'userInput' is not null or undefined
            assertParamExists('usersUpdate', 'userInput', userInput)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserInput} userInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreate(userInput: UserInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(userInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [role] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(role?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserInput} [patchedUserInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(id: number, patchedUserInput?: PatchedUserInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(id, patchedUserInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserInput} userInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: number, userInput: UserInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, userInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {UserInput} userInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(userInput: UserInput, options?: RawAxiosRequestConfig): AxiosPromise<UserInput> {
            return localVarFp.usersCreate(userInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [role] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(role?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.usersList(role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserInput} [patchedUserInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id: number, patchedUserInput?: PatchedUserInput, options?: RawAxiosRequestConfig): AxiosPromise<UserInput> {
            return localVarFp.usersPartialUpdate(id, patchedUserInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserInput} userInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: number, userInput: UserInput, options?: RawAxiosRequestConfig): AxiosPromise<UserInput> {
            return localVarFp.usersUpdate(id, userInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {UserInput} userInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreate(userInput: UserInput, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCreate(userInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDestroy(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [role] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersList(role?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersList(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUserInput} [patchedUserInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(id: number, patchedUserInput?: PatchedUserInput, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPartialUpdate(id, patchedUserInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {UserInput} userInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: number, userInput: UserInput, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdate(id, userInput, options).then((request) => request(this.axios, this.basePath));
    }
}



