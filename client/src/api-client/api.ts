/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AttendanceDetail
 */
export interface AttendanceDetail {
    /**
     * 
     * @type {string}
     * @memberof AttendanceDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AttendanceDetail
     */
    'attendance_record': string;
    /**
     * 
     * @type {number}
     * @memberof AttendanceDetail
     */
    'student': number;
    /**
     * 
     * @type {string}
     * @memberof AttendanceDetail
     */
    'class_session': string;
    /**
     * 
     * @type {string}
     * @memberof AttendanceDetail
     */
    'course': string;
    /**
     * 
     * @type {string}
     * @memberof AttendanceDetail
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof AttendanceDetail
     */
    'checked_in_at': string;
    /**
     * 
     * @type {number}
     * @memberof AttendanceDetail
     */
    'minutes_late': number;
    /**
     * 
     * @type {string}
     * @memberof AttendanceDetail
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface AttendanceRecord
 */
export interface AttendanceRecord {
    /**
     * 
     * @type {string}
     * @memberof AttendanceRecord
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AttendanceRecord
     */
    'checkin_session': string;
    /**
     * 
     * @type {number}
     * @memberof AttendanceRecord
     */
    'student': number;
    /**
     * 
     * @type {User}
     * @memberof AttendanceRecord
     */
    'student_detail': User;
    /**
     * 
     * @type {string}
     * @memberof AttendanceRecord
     */
    'checked_in_at': string;
    /**
     * 
     * @type {string}
     * @memberof AttendanceRecord
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface CheckinSession
 */
export interface CheckinSession {
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'class_session': string;
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'started_at': string;
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'closed_at': string;
    /**
     * 
     * @type {number}
     * @memberof CheckinSession
     */
    'created_by': number;
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof CheckinSession
     */
    'secret'?: string | null;
}
/**
 * 
 * @export
 * @interface Class
 */
export interface Class {
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'id': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof Class
     */
    'students': Array<User>;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'code': string;
    /**
     * 
     * @type {number}
     * @memberof Class
     */
    'year_of_graduation'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface ClassSession
 */
export interface ClassSession {
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'course': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'end_time': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'room': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSession
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ClassSessionDetail
 */
export interface ClassSessionDetail {
    /**
     * 
     * @type {string}
     * @memberof ClassSessionDetail
     */
    'id': string;
    /**
     * 
     * @type {Course}
     * @memberof ClassSessionDetail
     */
    'course': Course;
    /**
     * 
     * @type {string}
     * @memberof ClassSessionDetail
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSessionDetail
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSessionDetail
     */
    'end_time': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSessionDetail
     */
    'room': string;
    /**
     * 
     * @type {string}
     * @memberof ClassSessionDetail
     */
    'status': string;
    /**
     * 
     * @type {CheckinSession}
     * @memberof ClassSessionDetail
     */
    'checkin_session': CheckinSession;
}
/**
 * 
 * @export
 * @interface ClassStudent
 */
export interface ClassStudent {
    /**
     * 
     * @type {string}
     * @memberof ClassStudent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClassStudent
     */
    'class_group': string;
    /**
     * 
     * @type {number}
     * @memberof ClassStudent
     */
    'student': number;
}
/**
 * 
 * @export
 * @interface Course
 */
export interface Course {
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'code': string;
    /**
     * 
     * @type {User}
     * @memberof Course
     */
    'professor': User;
    /**
     * 
     * @type {number}
     * @memberof Course
     */
    'professor_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface CourseEnrollment
 */
export interface CourseEnrollment {
    /**
     * 
     * @type {string}
     * @memberof CourseEnrollment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEnrollment
     */
    'course_id': string;
    /**
     * 
     * @type {string}
     * @memberof CourseEnrollment
     */
    'class_group_id': string;
    /**
     * 
     * @type {Course}
     * @memberof CourseEnrollment
     */
    'course': Course;
    /**
     * 
     * @type {Class}
     * @memberof CourseEnrollment
     */
    'class_group': Class;
    /**
     * 
     * @type {string}
     * @memberof CourseEnrollment
     */
    'enrolled_at': string;
}
/**
 * 
 * @export
 * @interface CreateImportResponse
 */
export interface CreateImportResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateImportResponse
     */
    'import_id': string;
    /**
     * 
     * @type {StatusEnum}
     * @memberof CreateImportResponse
     */
    'status': StatusEnum;
}


/**
 * 
 * @export
 * @interface Grade
 */
export interface Grade {
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'course': string;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'max_value': string;
    /**
     * Pourcentage de la note finale
     * @type {string}
     * @memberof Grade
     */
    'coef': string;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'description'?: string | null;
    /**
     * 
     * @type {Class}
     * @memberof Grade
     */
    'class_group': Class;
    /**
     * 
     * @type {Array<StudentGrade>}
     * @memberof Grade
     */
    'student_grades': Array<StudentGrade>;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface Import
 */
export interface Import {
    /**
     * 
     * @type {string}
     * @memberof Import
     */
    'file': string;
}
/**
 * 
 * @export
 * @interface ImportStatus
 */
export interface ImportStatus {
    /**
     * 
     * @type {string}
     * @memberof ImportStatus
     */
    'import_id': string;
    /**
     * 
     * @type {TypeEnum}
     * @memberof ImportStatus
     */
    'type': TypeEnum;
    /**
     * 
     * @type {StatusEnum}
     * @memberof ImportStatus
     */
    'status': StatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ImportStatus
     */
    'progress': number;
    /**
     * 
     * @type {string}
     * @memberof ImportStatus
     */
    'imported_by': string;
    /**
     * 
     * @type {any}
     * @memberof ImportStatus
     */
    'results'?: any;
    /**
     * 
     * @type {string}
     * @memberof ImportStatus
     */
    'error'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImportStatus
     */
    'warnings'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ImportStatus
     */
    'finished_at': string;
    /**
     * 
     * @type {string}
     * @memberof ImportStatus
     */
    'started_at': string;
}


/**
 * 
 * @export
 * @interface PatchedAttendanceDetail
 */
export interface PatchedAttendanceDetail {
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceDetail
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceDetail
     */
    'attendance_record'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedAttendanceDetail
     */
    'student'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceDetail
     */
    'class_session'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceDetail
     */
    'course'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceDetail
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceDetail
     */
    'checked_in_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedAttendanceDetail
     */
    'minutes_late'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceDetail
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedAttendanceRecord
 */
export interface PatchedAttendanceRecord {
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceRecord
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceRecord
     */
    'checkin_session'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedAttendanceRecord
     */
    'student'?: number;
    /**
     * 
     * @type {User}
     * @memberof PatchedAttendanceRecord
     */
    'student_detail'?: User;
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceRecord
     */
    'checked_in_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAttendanceRecord
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface PatchedCheckinSession
 */
export interface PatchedCheckinSession {
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'class_session'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'started_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'closed_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedCheckinSession
     */
    'created_by'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCheckinSession
     */
    'secret'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedClass
 */
export interface PatchedClass {
    /**
     * 
     * @type {string}
     * @memberof PatchedClass
     */
    'id'?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedClass
     */
    'students'?: Array<User>;
    /**
     * 
     * @type {string}
     * @memberof PatchedClass
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClass
     */
    'code'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedClass
     */
    'year_of_graduation'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedClass
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClass
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedClassSessionDetail
 */
export interface PatchedClassSessionDetail {
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSessionDetail
     */
    'id'?: string;
    /**
     * 
     * @type {Course}
     * @memberof PatchedClassSessionDetail
     */
    'course'?: Course;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSessionDetail
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSessionDetail
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSessionDetail
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSessionDetail
     */
    'room'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassSessionDetail
     */
    'status'?: string;
    /**
     * 
     * @type {CheckinSession}
     * @memberof PatchedClassSessionDetail
     */
    'checkin_session'?: CheckinSession;
}
/**
 * 
 * @export
 * @interface PatchedClassStudent
 */
export interface PatchedClassStudent {
    /**
     * 
     * @type {string}
     * @memberof PatchedClassStudent
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedClassStudent
     */
    'class_group'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedClassStudent
     */
    'student'?: number;
}
/**
 * 
 * @export
 * @interface PatchedCourse
 */
export interface PatchedCourse {
    /**
     * 
     * @type {string}
     * @memberof PatchedCourse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCourse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCourse
     */
    'code'?: string;
    /**
     * 
     * @type {User}
     * @memberof PatchedCourse
     */
    'professor'?: User;
    /**
     * 
     * @type {number}
     * @memberof PatchedCourse
     */
    'professor_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCourse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCourse
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedCourseEnrollment
 */
export interface PatchedCourseEnrollment {
    /**
     * 
     * @type {string}
     * @memberof PatchedCourseEnrollment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCourseEnrollment
     */
    'course_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCourseEnrollment
     */
    'class_group_id'?: string;
    /**
     * 
     * @type {Course}
     * @memberof PatchedCourseEnrollment
     */
    'course'?: Course;
    /**
     * 
     * @type {Class}
     * @memberof PatchedCourseEnrollment
     */
    'class_group'?: Class;
    /**
     * 
     * @type {string}
     * @memberof PatchedCourseEnrollment
     */
    'enrolled_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedGrade
 */
export interface PatchedGrade {
    /**
     * 
     * @type {string}
     * @memberof PatchedGrade
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedGrade
     */
    'course'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedGrade
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedGrade
     */
    'max_value'?: string;
    /**
     * Pourcentage de la note finale
     * @type {string}
     * @memberof PatchedGrade
     */
    'coef'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedGrade
     */
    'description'?: string | null;
    /**
     * 
     * @type {Class}
     * @memberof PatchedGrade
     */
    'class_group'?: Class;
    /**
     * 
     * @type {Array<StudentGrade>}
     * @memberof PatchedGrade
     */
    'student_grades'?: Array<StudentGrade>;
    /**
     * 
     * @type {string}
     * @memberof PatchedGrade
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedGrade
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedStudentGrade
 */
export interface PatchedStudentGrade {
    /**
     * 
     * @type {string}
     * @memberof PatchedStudentGrade
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStudentGrade
     */
    'grade'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedStudentGrade
     */
    'student'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedStudentGrade
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStudentGrade
     */
    'comment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStudentGrade
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStudentGrade
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface PatchedUser
 */
export interface PatchedUser {
    /**
     * 
     * @type {number}
     * @memberof PatchedUser
     */
    'id'?: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof PatchedUser
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUser
     */
    'has_changed_password'?: boolean;
    /**
     * 
     * @type {RoleEnum}
     * @memberof PatchedUser
     */
    'role'?: RoleEnum;
    /**
     * 
     * @type {UserRoleEnum}
     * @memberof PatchedUser
     */
    'user_role'?: UserRoleEnum;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RoleEnum = {
    Admin: 'admin',
    Teacher: 'teacher',
    Student: 'student'
} as const;

export type RoleEnum = typeof RoleEnum[keyof typeof RoleEnum];


/**
 * * `processing` - processing * `completed` - completed * `failed` - failed
 * @export
 * @enum {string}
 */

export const StatusEnum = {
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type StatusEnum = typeof StatusEnum[keyof typeof StatusEnum];


/**
 * 
 * @export
 * @interface StudentGrade
 */
export interface StudentGrade {
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'grade': string;
    /**
     * 
     * @type {number}
     * @memberof StudentGrade
     */
    'student': number;
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'comment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof StudentGrade
     */
    'updated_at': string;
}
/**
 * * `users` - users * `classes` - classes * `courses` - courses
 * @export
 * @enum {string}
 */

export const TypeEnum = {
    Users: 'users',
    Classes: 'classes',
    Courses: 'courses'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'has_changed_password'?: boolean;
    /**
     * 
     * @type {RoleEnum}
     * @memberof User
     */
    'role': RoleEnum;
    /**
     * 
     * @type {UserRoleEnum}
     * @memberof User
     */
    'user_role': UserRoleEnum;
}


/**
 * * `student` - student * `teacher` - teacher * `admin` - admin
 * @export
 * @enum {string}
 */

export const UserRoleEnum = {
    Student: 'student',
    Teacher: 'teacher',
    Admin: 'admin'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];



/**
 * AttendanceDetailsApi - axios parameter creator
 * @export
 */
export const AttendanceDetailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AttendanceDetail} attendanceDetail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsCreate: async (attendanceDetail: AttendanceDetail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attendanceDetail' is not null or undefined
            assertParamExists('attendanceDetailsCreate', 'attendanceDetail', attendanceDetail)
            const localVarPath = `/attendance_details/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attendanceDetail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attendanceDetailsDestroy', 'id', id)
            const localVarPath = `/attendance_details/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attendance_details/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {PatchedAttendanceDetail} [patchedAttendanceDetail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsPartialUpdate: async (id: string, patchedAttendanceDetail?: PatchedAttendanceDetail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attendanceDetailsPartialUpdate', 'id', id)
            const localVarPath = `/attendance_details/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAttendanceDetail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attendanceDetailsRetrieve', 'id', id)
            const localVarPath = `/attendance_details/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {AttendanceDetail} attendanceDetail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsUpdate: async (id: string, attendanceDetail: AttendanceDetail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attendanceDetailsUpdate', 'id', id)
            // verify required parameter 'attendanceDetail' is not null or undefined
            assertParamExists('attendanceDetailsUpdate', 'attendanceDetail', attendanceDetail)
            const localVarPath = `/attendance_details/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attendanceDetail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttendanceDetailsApi - functional programming interface
 * @export
 */
export const AttendanceDetailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttendanceDetailsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AttendanceDetail} attendanceDetail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceDetailsCreate(attendanceDetail: AttendanceDetail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsCreate(attendanceDetail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceDetailsApi.attendanceDetailsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceDetailsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceDetailsApi.attendanceDetailsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceDetailsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttendanceDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceDetailsApi.attendanceDetailsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {PatchedAttendanceDetail} [patchedAttendanceDetail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceDetailsPartialUpdate(id: string, patchedAttendanceDetail?: PatchedAttendanceDetail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsPartialUpdate(id, patchedAttendanceDetail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceDetailsApi.attendanceDetailsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceDetailsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceDetailsApi.attendanceDetailsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {AttendanceDetail} attendanceDetail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceDetailsUpdate(id: string, attendanceDetail: AttendanceDetail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsUpdate(id, attendanceDetail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceDetailsApi.attendanceDetailsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AttendanceDetailsApi - factory interface
 * @export
 */
export const AttendanceDetailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttendanceDetailsApiFp(configuration)
    return {
        /**
         * 
         * @param {AttendanceDetail} attendanceDetail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsCreate(attendanceDetail: AttendanceDetail, options?: RawAxiosRequestConfig): AxiosPromise<AttendanceDetail> {
            return localVarFp.attendanceDetailsCreate(attendanceDetail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.attendanceDetailsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<AttendanceDetail>> {
            return localVarFp.attendanceDetailsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {PatchedAttendanceDetail} [patchedAttendanceDetail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsPartialUpdate(id: string, patchedAttendanceDetail?: PatchedAttendanceDetail, options?: RawAxiosRequestConfig): AxiosPromise<AttendanceDetail> {
            return localVarFp.attendanceDetailsPartialUpdate(id, patchedAttendanceDetail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AttendanceDetail> {
            return localVarFp.attendanceDetailsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance detail.
         * @param {AttendanceDetail} attendanceDetail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceDetailsUpdate(id: string, attendanceDetail: AttendanceDetail, options?: RawAxiosRequestConfig): AxiosPromise<AttendanceDetail> {
            return localVarFp.attendanceDetailsUpdate(id, attendanceDetail, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttendanceDetailsApi - object-oriented interface
 * @export
 * @class AttendanceDetailsApi
 * @extends {BaseAPI}
 */
export class AttendanceDetailsApi extends BaseAPI {
    /**
     * 
     * @param {AttendanceDetail} attendanceDetail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceDetailsApi
     */
    public attendanceDetailsCreate(attendanceDetail: AttendanceDetail, options?: RawAxiosRequestConfig) {
        return AttendanceDetailsApiFp(this.configuration).attendanceDetailsCreate(attendanceDetail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this attendance detail.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceDetailsApi
     */
    public attendanceDetailsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return AttendanceDetailsApiFp(this.configuration).attendanceDetailsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceDetailsApi
     */
    public attendanceDetailsList(options?: RawAxiosRequestConfig) {
        return AttendanceDetailsApiFp(this.configuration).attendanceDetailsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this attendance detail.
     * @param {PatchedAttendanceDetail} [patchedAttendanceDetail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceDetailsApi
     */
    public attendanceDetailsPartialUpdate(id: string, patchedAttendanceDetail?: PatchedAttendanceDetail, options?: RawAxiosRequestConfig) {
        return AttendanceDetailsApiFp(this.configuration).attendanceDetailsPartialUpdate(id, patchedAttendanceDetail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this attendance detail.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceDetailsApi
     */
    public attendanceDetailsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return AttendanceDetailsApiFp(this.configuration).attendanceDetailsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this attendance detail.
     * @param {AttendanceDetail} attendanceDetail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceDetailsApi
     */
    public attendanceDetailsUpdate(id: string, attendanceDetail: AttendanceDetail, options?: RawAxiosRequestConfig) {
        return AttendanceDetailsApiFp(this.configuration).attendanceDetailsUpdate(id, attendanceDetail, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AttendanceRecordsApi - axios parameter creator
 * @export
 */
export const AttendanceRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AttendanceRecord} attendanceRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsCreate: async (attendanceRecord: AttendanceRecord, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attendanceRecord' is not null or undefined
            assertParamExists('attendanceRecordsCreate', 'attendanceRecord', attendanceRecord)
            const localVarPath = `/attendance_records/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attendanceRecord, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attendanceRecordsDestroy', 'id', id)
            const localVarPath = `/attendance_records/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attendance_records/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {PatchedAttendanceRecord} [patchedAttendanceRecord] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsPartialUpdate: async (id: string, patchedAttendanceRecord?: PatchedAttendanceRecord, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attendanceRecordsPartialUpdate', 'id', id)
            const localVarPath = `/attendance_records/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAttendanceRecord, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attendanceRecordsRetrieve', 'id', id)
            const localVarPath = `/attendance_records/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {AttendanceRecord} attendanceRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsUpdate: async (id: string, attendanceRecord: AttendanceRecord, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attendanceRecordsUpdate', 'id', id)
            // verify required parameter 'attendanceRecord' is not null or undefined
            assertParamExists('attendanceRecordsUpdate', 'attendanceRecord', attendanceRecord)
            const localVarPath = `/attendance_records/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attendanceRecord, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttendanceRecordsApi - functional programming interface
 * @export
 */
export const AttendanceRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttendanceRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AttendanceRecord} attendanceRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceRecordsCreate(attendanceRecord: AttendanceRecord, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsCreate(attendanceRecord, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceRecordsApi.attendanceRecordsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceRecordsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceRecordsApi.attendanceRecordsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceRecordsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttendanceRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceRecordsApi.attendanceRecordsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {PatchedAttendanceRecord} [patchedAttendanceRecord] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceRecordsPartialUpdate(id: string, patchedAttendanceRecord?: PatchedAttendanceRecord, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsPartialUpdate(id, patchedAttendanceRecord, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceRecordsApi.attendanceRecordsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceRecordsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceRecordsApi.attendanceRecordsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {AttendanceRecord} attendanceRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attendanceRecordsUpdate(id: string, attendanceRecord: AttendanceRecord, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsUpdate(id, attendanceRecord, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttendanceRecordsApi.attendanceRecordsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AttendanceRecordsApi - factory interface
 * @export
 */
export const AttendanceRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttendanceRecordsApiFp(configuration)
    return {
        /**
         * 
         * @param {AttendanceRecord} attendanceRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsCreate(attendanceRecord: AttendanceRecord, options?: RawAxiosRequestConfig): AxiosPromise<AttendanceRecord> {
            return localVarFp.attendanceRecordsCreate(attendanceRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.attendanceRecordsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<AttendanceRecord>> {
            return localVarFp.attendanceRecordsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {PatchedAttendanceRecord} [patchedAttendanceRecord] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsPartialUpdate(id: string, patchedAttendanceRecord?: PatchedAttendanceRecord, options?: RawAxiosRequestConfig): AxiosPromise<AttendanceRecord> {
            return localVarFp.attendanceRecordsPartialUpdate(id, patchedAttendanceRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AttendanceRecord> {
            return localVarFp.attendanceRecordsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this attendance record.
         * @param {AttendanceRecord} attendanceRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attendanceRecordsUpdate(id: string, attendanceRecord: AttendanceRecord, options?: RawAxiosRequestConfig): AxiosPromise<AttendanceRecord> {
            return localVarFp.attendanceRecordsUpdate(id, attendanceRecord, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttendanceRecordsApi - object-oriented interface
 * @export
 * @class AttendanceRecordsApi
 * @extends {BaseAPI}
 */
export class AttendanceRecordsApi extends BaseAPI {
    /**
     * 
     * @param {AttendanceRecord} attendanceRecord 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceRecordsApi
     */
    public attendanceRecordsCreate(attendanceRecord: AttendanceRecord, options?: RawAxiosRequestConfig) {
        return AttendanceRecordsApiFp(this.configuration).attendanceRecordsCreate(attendanceRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this attendance record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceRecordsApi
     */
    public attendanceRecordsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return AttendanceRecordsApiFp(this.configuration).attendanceRecordsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceRecordsApi
     */
    public attendanceRecordsList(options?: RawAxiosRequestConfig) {
        return AttendanceRecordsApiFp(this.configuration).attendanceRecordsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this attendance record.
     * @param {PatchedAttendanceRecord} [patchedAttendanceRecord] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceRecordsApi
     */
    public attendanceRecordsPartialUpdate(id: string, patchedAttendanceRecord?: PatchedAttendanceRecord, options?: RawAxiosRequestConfig) {
        return AttendanceRecordsApiFp(this.configuration).attendanceRecordsPartialUpdate(id, patchedAttendanceRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this attendance record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceRecordsApi
     */
    public attendanceRecordsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return AttendanceRecordsApiFp(this.configuration).attendanceRecordsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this attendance record.
     * @param {AttendanceRecord} attendanceRecord 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceRecordsApi
     */
    public attendanceRecordsUpdate(id: string, attendanceRecord: AttendanceRecord, options?: RawAxiosRequestConfig) {
        return AttendanceRecordsApiFp(this.configuration).attendanceRecordsUpdate(id, attendanceRecord, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CheckinSessionsApi - axios parameter creator
 * @export
 */
export const CheckinSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CheckinSession} checkinSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsCreate: async (checkinSession: CheckinSession, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkinSession' is not null or undefined
            assertParamExists('checkinSessionsCreate', 'checkinSession', checkinSession)
            const localVarPath = `/checkin_sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkinSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsDestroy', 'id', id)
            const localVarPath = `/checkin_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/checkin_sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {PatchedCheckinSession} [patchedCheckinSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsPartialUpdate: async (id: string, patchedCheckinSession?: PatchedCheckinSession, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsPartialUpdate', 'id', id)
            const localVarPath = `/checkin_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCheckinSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsRetrieve', 'id', id)
            const localVarPath = `/checkin_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsTotpRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsTotpRetrieve', 'id', id)
            const localVarPath = `/checkin_sessions/{id}/totp/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {CheckinSession} checkinSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsUpdate: async (id: string, checkinSession: CheckinSession, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkinSessionsUpdate', 'id', id)
            // verify required parameter 'checkinSession' is not null or undefined
            assertParamExists('checkinSessionsUpdate', 'checkinSession', checkinSession)
            const localVarPath = `/checkin_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkinSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckinSessionsApi - functional programming interface
 * @export
 */
export const CheckinSessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckinSessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CheckinSession} checkinSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsCreate(checkinSession: CheckinSession, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsCreate(checkinSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CheckinSession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {PatchedCheckinSession} [patchedCheckinSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsPartialUpdate(id: string, patchedCheckinSession?: PatchedCheckinSession, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsPartialUpdate(id, patchedCheckinSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsTotpRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsTotpRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsTotpRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {CheckinSession} checkinSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkinSessionsUpdate(id: string, checkinSession: CheckinSession, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsUpdate(id, checkinSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckinSessionsApi.checkinSessionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CheckinSessionsApi - factory interface
 * @export
 */
export const CheckinSessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckinSessionsApiFp(configuration)
    return {
        /**
         * 
         * @param {CheckinSession} checkinSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsCreate(checkinSession: CheckinSession, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsCreate(checkinSession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.checkinSessionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CheckinSession>> {
            return localVarFp.checkinSessionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {PatchedCheckinSession} [patchedCheckinSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsPartialUpdate(id: string, patchedCheckinSession?: PatchedCheckinSession, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsPartialUpdate(id, patchedCheckinSession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsTotpRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsTotpRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this checkin session.
         * @param {CheckinSession} checkinSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkinSessionsUpdate(id: string, checkinSession: CheckinSession, options?: RawAxiosRequestConfig): AxiosPromise<CheckinSession> {
            return localVarFp.checkinSessionsUpdate(id, checkinSession, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckinSessionsApi - object-oriented interface
 * @export
 * @class CheckinSessionsApi
 * @extends {BaseAPI}
 */
export class CheckinSessionsApi extends BaseAPI {
    /**
     * 
     * @param {CheckinSession} checkinSession 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsCreate(checkinSession: CheckinSession, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsCreate(checkinSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsList(options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {PatchedCheckinSession} [patchedCheckinSession] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsPartialUpdate(id: string, patchedCheckinSession?: PatchedCheckinSession, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsPartialUpdate(id, patchedCheckinSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsTotpRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsTotpRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this checkin session.
     * @param {CheckinSession} checkinSession 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckinSessionsApi
     */
    public checkinSessionsUpdate(id: string, checkinSession: CheckinSession, options?: RawAxiosRequestConfig) {
        return CheckinSessionsApiFp(this.configuration).checkinSessionsUpdate(id, checkinSession, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClassSessionsApi - axios parameter creator
 * @export
 */
export const ClassSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ClassSession} classSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsCreate: async (classSession: ClassSession, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classSession' is not null or undefined
            assertParamExists('classSessionsCreate', 'classSession', classSession)
            const localVarPath = `/class_sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classSessionsDestroy', 'id', id)
            const localVarPath = `/class_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/class_sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {PatchedClassSessionDetail} [patchedClassSessionDetail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsPartialUpdate: async (id: string, patchedClassSessionDetail?: PatchedClassSessionDetail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classSessionsPartialUpdate', 'id', id)
            const localVarPath = `/class_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedClassSessionDetail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classSessionsRetrieve', 'id', id)
            const localVarPath = `/class_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {ClassSession} classSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsUpdate: async (id: string, classSession: ClassSession, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classSessionsUpdate', 'id', id)
            // verify required parameter 'classSession' is not null or undefined
            assertParamExists('classSessionsUpdate', 'classSession', classSession)
            const localVarPath = `/class_sessions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassSessionsApi - functional programming interface
 * @export
 */
export const ClassSessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassSessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ClassSession} classSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsCreate(classSession: ClassSession, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsCreate(classSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassSessionDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {PatchedClassSessionDetail} [patchedClassSessionDetail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsPartialUpdate(id: string, patchedClassSessionDetail?: PatchedClassSessionDetail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSessionDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsPartialUpdate(id, patchedClassSessionDetail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSessionDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {ClassSession} classSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classSessionsUpdate(id: string, classSession: ClassSession, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsUpdate(id, classSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassSessionsApi.classSessionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClassSessionsApi - factory interface
 * @export
 */
export const ClassSessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassSessionsApiFp(configuration)
    return {
        /**
         * 
         * @param {ClassSession} classSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsCreate(classSession: ClassSession, options?: RawAxiosRequestConfig): AxiosPromise<ClassSession> {
            return localVarFp.classSessionsCreate(classSession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.classSessionsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ClassSessionDetail>> {
            return localVarFp.classSessionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {PatchedClassSessionDetail} [patchedClassSessionDetail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsPartialUpdate(id: string, patchedClassSessionDetail?: PatchedClassSessionDetail, options?: RawAxiosRequestConfig): AxiosPromise<ClassSessionDetail> {
            return localVarFp.classSessionsPartialUpdate(id, patchedClassSessionDetail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ClassSessionDetail> {
            return localVarFp.classSessionsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class session.
         * @param {ClassSession} classSession 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classSessionsUpdate(id: string, classSession: ClassSession, options?: RawAxiosRequestConfig): AxiosPromise<ClassSession> {
            return localVarFp.classSessionsUpdate(id, classSession, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassSessionsApi - object-oriented interface
 * @export
 * @class ClassSessionsApi
 * @extends {BaseAPI}
 */
export class ClassSessionsApi extends BaseAPI {
    /**
     * 
     * @param {ClassSession} classSession 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsCreate(classSession: ClassSession, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsCreate(classSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsList(options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class session.
     * @param {PatchedClassSessionDetail} [patchedClassSessionDetail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsPartialUpdate(id: string, patchedClassSessionDetail?: PatchedClassSessionDetail, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsPartialUpdate(id, patchedClassSessionDetail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class session.
     * @param {ClassSession} classSession 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassSessionsApi
     */
    public classSessionsUpdate(id: string, classSession: ClassSession, options?: RawAxiosRequestConfig) {
        return ClassSessionsApiFp(this.configuration).classSessionsUpdate(id, classSession, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClassStudentsApi - axios parameter creator
 * @export
 */
export const ClassStudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ClassStudent} classStudent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsCreate: async (classStudent: ClassStudent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classStudent' is not null or undefined
            assertParamExists('classStudentsCreate', 'classStudent', classStudent)
            const localVarPath = `/class_students/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classStudent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classStudentsDestroy', 'id', id)
            const localVarPath = `/class_students/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/class_students/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {PatchedClassStudent} [patchedClassStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsPartialUpdate: async (id: string, patchedClassStudent?: PatchedClassStudent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classStudentsPartialUpdate', 'id', id)
            const localVarPath = `/class_students/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedClassStudent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classStudentsRetrieve', 'id', id)
            const localVarPath = `/class_students/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {ClassStudent} classStudent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsUpdate: async (id: string, classStudent: ClassStudent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classStudentsUpdate', 'id', id)
            // verify required parameter 'classStudent' is not null or undefined
            assertParamExists('classStudentsUpdate', 'classStudent', classStudent)
            const localVarPath = `/class_students/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classStudent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassStudentsApi - functional programming interface
 * @export
 */
export const ClassStudentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassStudentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ClassStudent} classStudent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsCreate(classStudent: ClassStudent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsCreate(classStudent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassStudent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {PatchedClassStudent} [patchedClassStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsPartialUpdate(id: string, patchedClassStudent?: PatchedClassStudent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsPartialUpdate(id, patchedClassStudent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {ClassStudent} classStudent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classStudentsUpdate(id: string, classStudent: ClassStudent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsUpdate(id, classStudent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassStudentsApi.classStudentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClassStudentsApi - factory interface
 * @export
 */
export const ClassStudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassStudentsApiFp(configuration)
    return {
        /**
         * 
         * @param {ClassStudent} classStudent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsCreate(classStudent: ClassStudent, options?: RawAxiosRequestConfig): AxiosPromise<ClassStudent> {
            return localVarFp.classStudentsCreate(classStudent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.classStudentsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ClassStudent>> {
            return localVarFp.classStudentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {PatchedClassStudent} [patchedClassStudent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsPartialUpdate(id: string, patchedClassStudent?: PatchedClassStudent, options?: RawAxiosRequestConfig): AxiosPromise<ClassStudent> {
            return localVarFp.classStudentsPartialUpdate(id, patchedClassStudent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ClassStudent> {
            return localVarFp.classStudentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class student.
         * @param {ClassStudent} classStudent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classStudentsUpdate(id: string, classStudent: ClassStudent, options?: RawAxiosRequestConfig): AxiosPromise<ClassStudent> {
            return localVarFp.classStudentsUpdate(id, classStudent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassStudentsApi - object-oriented interface
 * @export
 * @class ClassStudentsApi
 * @extends {BaseAPI}
 */
export class ClassStudentsApi extends BaseAPI {
    /**
     * 
     * @param {ClassStudent} classStudent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsCreate(classStudent: ClassStudent, options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsCreate(classStudent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class student.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsList(options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class student.
     * @param {PatchedClassStudent} [patchedClassStudent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsPartialUpdate(id: string, patchedClassStudent?: PatchedClassStudent, options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsPartialUpdate(id, patchedClassStudent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class student.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class student.
     * @param {ClassStudent} classStudent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassStudentsApi
     */
    public classStudentsUpdate(id: string, classStudent: ClassStudent, options?: RawAxiosRequestConfig) {
        return ClassStudentsApiFp(this.configuration).classStudentsUpdate(id, classStudent, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClassesApi - axios parameter creator
 * @export
 */
export const ClassesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesBulkDeleteCreate: async (_class: Class, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('classesBulkDeleteCreate', '_class', _class)
            const localVarPath = `/classes/bulk_delete/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_class, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesCreate: async (_class: Class, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_class' is not null or undefined
            assertParamExists('classesCreate', '_class', _class)
            const localVarPath = `/classes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_class, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesDestroy', 'id', id)
            const localVarPath = `/classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/classes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {PatchedClass} [patchedClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesPartialUpdate: async (id: string, patchedClass?: PatchedClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesPartialUpdate', 'id', id)
            const localVarPath = `/classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesRetrieve', 'id', id)
            const localVarPath = `/classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdate: async (id: string, _class: Class, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesUpdate', 'id', id)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('classesUpdate', '_class', _class)
            const localVarPath = `/classes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_class, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdateStudentsUpdate: async (id: string, _class: Class, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesUpdateStudentsUpdate', 'id', id)
            // verify required parameter '_class' is not null or undefined
            assertParamExists('classesUpdateStudentsUpdate', '_class', _class)
            const localVarPath = `/classes/{id}/update_students/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_class, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassesApi - functional programming interface
 * @export
 */
export const ClassesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesBulkDeleteCreate(_class: Class, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesBulkDeleteCreate(_class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesBulkDeleteCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesCreate(_class: Class, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesCreate(_class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Class>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {PatchedClass} [patchedClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesPartialUpdate(id: string, patchedClass?: PatchedClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesPartialUpdate(id, patchedClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesUpdate(id, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesUpdateStudentsUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesUpdateStudentsUpdate(id, _class, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassesApi.classesUpdateStudentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClassesApi - factory interface
 * @export
 */
export const ClassesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassesApiFp(configuration)
    return {
        /**
         * 
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesBulkDeleteCreate(_class: Class, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesBulkDeleteCreate(_class, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesCreate(_class: Class, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesCreate(_class, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.classesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Class>> {
            return localVarFp.classesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {PatchedClass} [patchedClass] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesPartialUpdate(id: string, patchedClass?: PatchedClass, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesPartialUpdate(id, patchedClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesUpdate(id, _class, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this class.
         * @param {Class} _class 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdateStudentsUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
            return localVarFp.classesUpdateStudentsUpdate(id, _class, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassesApi - object-oriented interface
 * @export
 * @class ClassesApi
 * @extends {BaseAPI}
 */
export class ClassesApi extends BaseAPI {
    /**
     * 
     * @param {Class} _class 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesBulkDeleteCreate(_class: Class, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesBulkDeleteCreate(_class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Class} _class 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesCreate(_class: Class, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesCreate(_class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesList(options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class.
     * @param {PatchedClass} [patchedClass] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesPartialUpdate(id: string, patchedClass?: PatchedClass, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesPartialUpdate(id, patchedClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class.
     * @param {Class} _class 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesUpdate(id, _class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this class.
     * @param {Class} _class 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesUpdateStudentsUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesUpdateStudentsUpdate(id, _class, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseEnrollmentsApi - axios parameter creator
 * @export
 */
export const CourseEnrollmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CourseEnrollment} courseEnrollment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsBulkDeleteCreate: async (courseEnrollment: CourseEnrollment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseEnrollment' is not null or undefined
            assertParamExists('courseEnrollmentsBulkDeleteCreate', 'courseEnrollment', courseEnrollment)
            const localVarPath = `/course_enrollments/bulk_delete/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseEnrollment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CourseEnrollment} courseEnrollment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsCreate: async (courseEnrollment: CourseEnrollment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseEnrollment' is not null or undefined
            assertParamExists('courseEnrollmentsCreate', 'courseEnrollment', courseEnrollment)
            const localVarPath = `/course_enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseEnrollment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('courseEnrollmentsDestroy', 'id', id)
            const localVarPath = `/course_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/course_enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {PatchedCourseEnrollment} [patchedCourseEnrollment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsPartialUpdate: async (id: string, patchedCourseEnrollment?: PatchedCourseEnrollment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('courseEnrollmentsPartialUpdate', 'id', id)
            const localVarPath = `/course_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCourseEnrollment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('courseEnrollmentsRetrieve', 'id', id)
            const localVarPath = `/course_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {CourseEnrollment} courseEnrollment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsUpdate: async (id: string, courseEnrollment: CourseEnrollment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('courseEnrollmentsUpdate', 'id', id)
            // verify required parameter 'courseEnrollment' is not null or undefined
            assertParamExists('courseEnrollmentsUpdate', 'courseEnrollment', courseEnrollment)
            const localVarPath = `/course_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseEnrollment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseEnrollmentsApi - functional programming interface
 * @export
 */
export const CourseEnrollmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseEnrollmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CourseEnrollment} courseEnrollment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseEnrollmentsBulkDeleteCreate(courseEnrollment: CourseEnrollment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEnrollment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsBulkDeleteCreate(courseEnrollment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentsApi.courseEnrollmentsBulkDeleteCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CourseEnrollment} courseEnrollment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseEnrollmentsCreate(courseEnrollment: CourseEnrollment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEnrollment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsCreate(courseEnrollment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentsApi.courseEnrollmentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseEnrollmentsDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentsApi.courseEnrollmentsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseEnrollmentsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseEnrollment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentsApi.courseEnrollmentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {PatchedCourseEnrollment} [patchedCourseEnrollment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseEnrollmentsPartialUpdate(id: string, patchedCourseEnrollment?: PatchedCourseEnrollment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEnrollment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsPartialUpdate(id, patchedCourseEnrollment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentsApi.courseEnrollmentsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseEnrollmentsRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEnrollment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentsApi.courseEnrollmentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {CourseEnrollment} courseEnrollment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseEnrollmentsUpdate(id: string, courseEnrollment: CourseEnrollment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEnrollment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsUpdate(id, courseEnrollment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentsApi.courseEnrollmentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseEnrollmentsApi - factory interface
 * @export
 */
export const CourseEnrollmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseEnrollmentsApiFp(configuration)
    return {
        /**
         * 
         * @param {CourseEnrollment} courseEnrollment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsBulkDeleteCreate(courseEnrollment: CourseEnrollment, options?: RawAxiosRequestConfig): AxiosPromise<CourseEnrollment> {
            return localVarFp.courseEnrollmentsBulkDeleteCreate(courseEnrollment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CourseEnrollment} courseEnrollment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsCreate(courseEnrollment: CourseEnrollment, options?: RawAxiosRequestConfig): AxiosPromise<CourseEnrollment> {
            return localVarFp.courseEnrollmentsCreate(courseEnrollment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.courseEnrollmentsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CourseEnrollment>> {
            return localVarFp.courseEnrollmentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {PatchedCourseEnrollment} [patchedCourseEnrollment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsPartialUpdate(id: string, patchedCourseEnrollment?: PatchedCourseEnrollment, options?: RawAxiosRequestConfig): AxiosPromise<CourseEnrollment> {
            return localVarFp.courseEnrollmentsPartialUpdate(id, patchedCourseEnrollment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CourseEnrollment> {
            return localVarFp.courseEnrollmentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course enrollment.
         * @param {CourseEnrollment} courseEnrollment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollmentsUpdate(id: string, courseEnrollment: CourseEnrollment, options?: RawAxiosRequestConfig): AxiosPromise<CourseEnrollment> {
            return localVarFp.courseEnrollmentsUpdate(id, courseEnrollment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseEnrollmentsApi - object-oriented interface
 * @export
 * @class CourseEnrollmentsApi
 * @extends {BaseAPI}
 */
export class CourseEnrollmentsApi extends BaseAPI {
    /**
     * 
     * @param {CourseEnrollment} courseEnrollment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentsApi
     */
    public courseEnrollmentsBulkDeleteCreate(courseEnrollment: CourseEnrollment, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentsApiFp(this.configuration).courseEnrollmentsBulkDeleteCreate(courseEnrollment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CourseEnrollment} courseEnrollment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentsApi
     */
    public courseEnrollmentsCreate(courseEnrollment: CourseEnrollment, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentsApiFp(this.configuration).courseEnrollmentsCreate(courseEnrollment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course enrollment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentsApi
     */
    public courseEnrollmentsDestroy(id: string, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentsApiFp(this.configuration).courseEnrollmentsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentsApi
     */
    public courseEnrollmentsList(options?: RawAxiosRequestConfig) {
        return CourseEnrollmentsApiFp(this.configuration).courseEnrollmentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course enrollment.
     * @param {PatchedCourseEnrollment} [patchedCourseEnrollment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentsApi
     */
    public courseEnrollmentsPartialUpdate(id: string, patchedCourseEnrollment?: PatchedCourseEnrollment, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentsApiFp(this.configuration).courseEnrollmentsPartialUpdate(id, patchedCourseEnrollment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course enrollment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentsApi
     */
    public courseEnrollmentsRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentsApiFp(this.configuration).courseEnrollmentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course enrollment.
     * @param {CourseEnrollment} courseEnrollment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentsApi
     */
    public courseEnrollmentsUpdate(id: string, courseEnrollment: CourseEnrollment, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentsApiFp(this.configuration).courseEnrollmentsUpdate(id, courseEnrollment, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Course} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesBulkDeleteCreate: async (course: Course, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'course' is not null or undefined
            assertParamExists('coursesBulkDeleteCreate', 'course', course)
            const localVarPath = `/courses/bulk_delete/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(course, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Course} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesCreate: async (course: Course, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'course' is not null or undefined
            assertParamExists('coursesCreate', 'course', course)
            const localVarPath = `/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(course, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coursesDestroy', 'id', id)
            const localVarPath = `/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {PatchedCourse} [patchedCourse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesPartialUpdate: async (id: string, patchedCourse?: PatchedCourse, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coursesPartialUpdate', 'id', id)
            const localVarPath = `/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCourse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coursesRetrieve', 'id', id)
            const localVarPath = `/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {Course} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesUpdate: async (id: string, course: Course, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('coursesUpdate', 'id', id)
            // verify required parameter 'course' is not null or undefined
            assertParamExists('coursesUpdate', 'course', course)
            const localVarPath = `/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(course, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Course} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesBulkDeleteCreate(course: Course, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesBulkDeleteCreate(course, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesBulkDeleteCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Course} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesCreate(course: Course, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesCreate(course, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {PatchedCourse} [patchedCourse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesPartialUpdate(id: string, patchedCourse?: PatchedCourse, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesPartialUpdate(id, patchedCourse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {Course} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesUpdate(id: string, course: Course, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesUpdate(id, course, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoursesApi.coursesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesApiFp(configuration)
    return {
        /**
         * 
         * @param {Course} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesBulkDeleteCreate(course: Course, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.coursesBulkDeleteCreate(course, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Course} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesCreate(course: Course, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.coursesCreate(course, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coursesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Course>> {
            return localVarFp.coursesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {PatchedCourse} [patchedCourse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesPartialUpdate(id: string, patchedCourse?: PatchedCourse, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.coursesPartialUpdate(id, patchedCourse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.coursesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this course.
         * @param {Course} course 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesUpdate(id: string, course: Course, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
            return localVarFp.coursesUpdate(id, course, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
    /**
     * 
     * @param {Course} course 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesBulkDeleteCreate(course: Course, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesBulkDeleteCreate(course, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Course} course 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesCreate(course: Course, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesCreate(course, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesList(options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course.
     * @param {PatchedCourse} [patchedCourse] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesPartialUpdate(id: string, patchedCourse?: PatchedCourse, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesPartialUpdate(id, patchedCourse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this course.
     * @param {Course} course 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public coursesUpdate(id: string, course: Course, options?: RawAxiosRequestConfig) {
        return CoursesApiFp(this.configuration).coursesUpdate(id, course, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GradesApi - axios parameter creator
 * @export
 */
export const GradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Grade} grade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesCreate: async (grade: Grade, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grade' is not null or undefined
            assertParamExists('gradesCreate', 'grade', grade)
            const localVarPath = `/grades/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(grade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gradesDestroy', 'id', id)
            const localVarPath = `/grades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/grades/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {PatchedGrade} [patchedGrade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesPartialUpdate: async (id: string, patchedGrade?: PatchedGrade, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gradesPartialUpdate', 'id', id)
            const localVarPath = `/grades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedGrade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gradesRetrieve', 'id', id)
            const localVarPath = `/grades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {Grade} grade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesUpdate: async (id: string, grade: Grade, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gradesUpdate', 'id', id)
            // verify required parameter 'grade' is not null or undefined
            assertParamExists('gradesUpdate', 'grade', grade)
            const localVarPath = `/grades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(grade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GradesApi - functional programming interface
 * @export
 */
export const GradesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GradesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Grade} grade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gradesCreate(grade: Grade, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gradesCreate(grade, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GradesApi.gradesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gradesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gradesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GradesApi.gradesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gradesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Grade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gradesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GradesApi.gradesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {PatchedGrade} [patchedGrade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gradesPartialUpdate(id: string, patchedGrade?: PatchedGrade, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gradesPartialUpdate(id, patchedGrade, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GradesApi.gradesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gradesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gradesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GradesApi.gradesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {Grade} grade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gradesUpdate(id: string, grade: Grade, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gradesUpdate(id, grade, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GradesApi.gradesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GradesApi - factory interface
 * @export
 */
export const GradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GradesApiFp(configuration)
    return {
        /**
         * 
         * @param {Grade} grade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesCreate(grade: Grade, options?: RawAxiosRequestConfig): AxiosPromise<Grade> {
            return localVarFp.gradesCreate(grade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.gradesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Grade>> {
            return localVarFp.gradesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {PatchedGrade} [patchedGrade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesPartialUpdate(id: string, patchedGrade?: PatchedGrade, options?: RawAxiosRequestConfig): AxiosPromise<Grade> {
            return localVarFp.gradesPartialUpdate(id, patchedGrade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Grade> {
            return localVarFp.gradesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this grade.
         * @param {Grade} grade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesUpdate(id: string, grade: Grade, options?: RawAxiosRequestConfig): AxiosPromise<Grade> {
            return localVarFp.gradesUpdate(id, grade, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GradesApi - object-oriented interface
 * @export
 * @class GradesApi
 * @extends {BaseAPI}
 */
export class GradesApi extends BaseAPI {
    /**
     * 
     * @param {Grade} grade 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradesApi
     */
    public gradesCreate(grade: Grade, options?: RawAxiosRequestConfig) {
        return GradesApiFp(this.configuration).gradesCreate(grade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this grade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradesApi
     */
    public gradesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return GradesApiFp(this.configuration).gradesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradesApi
     */
    public gradesList(options?: RawAxiosRequestConfig) {
        return GradesApiFp(this.configuration).gradesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this grade.
     * @param {PatchedGrade} [patchedGrade] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradesApi
     */
    public gradesPartialUpdate(id: string, patchedGrade?: PatchedGrade, options?: RawAxiosRequestConfig) {
        return GradesApiFp(this.configuration).gradesPartialUpdate(id, patchedGrade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this grade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradesApi
     */
    public gradesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return GradesApiFp(this.configuration).gradesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this grade.
     * @param {Grade} grade 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradesApi
     */
    public gradesUpdate(id: string, grade: Grade, options?: RawAxiosRequestConfig) {
        return GradesApiFp(this.configuration).gradesUpdate(id, grade, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImportApi - axios parameter creator
 * @export
 */
export const ImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new class import
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importClassesCreate: async (_import: Import, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_import' is not null or undefined
            assertParamExists('importClassesCreate', '_import', _import)
            const localVarPath = `/import/classes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_import, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves class import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importClassesRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/classes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new course import
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCoursesCreate: async (_import: Import, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_import' is not null or undefined
            assertParamExists('importCoursesCreate', '_import', _import)
            const localVarPath = `/import/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_import, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves course import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCoursesRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importRetrieve: async (importId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            assertParamExists('importRetrieve', 'importId', importId)
            const localVarPath = `/import/{import_id}/`
                .replace(`{${"import_id"}}`, encodeURIComponent(String(importId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user import
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsersCreate: async (_import: Import, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_import' is not null or undefined
            assertParamExists('importUsersCreate', '_import', _import)
            const localVarPath = `/import/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_import, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves user import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsersRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportApi - functional programming interface
 * @export
 */
export const ImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new class import
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importClassesCreate(_import: Import, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importClassesCreate(_import, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importClassesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves class import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importClassesRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importClassesRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importClassesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new course import
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCoursesCreate(_import: Import, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCoursesCreate(_import, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importCoursesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves course import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCoursesRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCoursesRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importCoursesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importRetrieve(importId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importRetrieve(importId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user import
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUsersCreate(_import: Import, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateImportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUsersCreate(_import, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importUsersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves user import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUsersRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUsersRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImportApi.importUsersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImportApi - factory interface
 * @export
 */
export const ImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportApiFp(configuration)
    return {
        /**
         * Creates a new class import
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importClassesCreate(_import: Import, options?: RawAxiosRequestConfig): AxiosPromise<CreateImportResponse> {
            return localVarFp.importClassesCreate(_import, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves class import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importClassesRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
            return localVarFp.importClassesRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new course import
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCoursesCreate(_import: Import, options?: RawAxiosRequestConfig): AxiosPromise<CreateImportResponse> {
            return localVarFp.importCoursesCreate(_import, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves course import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCoursesRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
            return localVarFp.importCoursesRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importRetrieve(importId: string, options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
            return localVarFp.importRetrieve(importId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user import
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsersCreate(_import: Import, options?: RawAxiosRequestConfig): AxiosPromise<CreateImportResponse> {
            return localVarFp.importUsersCreate(_import, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves user import information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsersRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
            return localVarFp.importUsersRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
export class ImportApi extends BaseAPI {
    /**
     * Creates a new class import
     * @param {Import} _import 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importClassesCreate(_import: Import, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importClassesCreate(_import, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves class import information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importClassesRetrieve(options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importClassesRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new course import
     * @param {Import} _import 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importCoursesCreate(_import: Import, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importCoursesCreate(_import, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves course import information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importCoursesRetrieve(options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importCoursesRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} importId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importRetrieve(importId: string, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importRetrieve(importId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user import
     * @param {Import} _import 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importUsersCreate(_import: Import, options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importUsersCreate(_import, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves user import information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public importUsersRetrieve(options?: RawAxiosRequestConfig) {
        return ImportApiFp(this.configuration).importUsersRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(format, lang, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemaApi.schemaRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {SchemaRetrieveFormatEnum} [format] 
         * @param {SchemaRetrieveLangEnum} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.schemaRetrieve(format, lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {SchemaRetrieveFormatEnum} [format] 
     * @param {SchemaRetrieveLangEnum} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(format?: SchemaRetrieveFormatEnum, lang?: SchemaRetrieveLangEnum, options?: RawAxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaRetrieve(format, lang, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SchemaRetrieveFormatEnum = {
    Json: 'json',
    Yaml: 'yaml'
} as const;
export type SchemaRetrieveFormatEnum = typeof SchemaRetrieveFormatEnum[keyof typeof SchemaRetrieveFormatEnum];
/**
 * @export
 */
export const SchemaRetrieveLangEnum = {
    Af: 'af',
    Ar: 'ar',
    ArDz: 'ar-dz',
    Ast: 'ast',
    Az: 'az',
    Be: 'be',
    Bg: 'bg',
    Bn: 'bn',
    Br: 'br',
    Bs: 'bs',
    Ca: 'ca',
    Ckb: 'ckb',
    Cs: 'cs',
    Cy: 'cy',
    Da: 'da',
    De: 'de',
    Dsb: 'dsb',
    El: 'el',
    En: 'en',
    EnAu: 'en-au',
    EnGb: 'en-gb',
    Eo: 'eo',
    Es: 'es',
    EsAr: 'es-ar',
    EsCo: 'es-co',
    EsMx: 'es-mx',
    EsNi: 'es-ni',
    EsVe: 'es-ve',
    Et: 'et',
    Eu: 'eu',
    Fa: 'fa',
    Fi: 'fi',
    Fr: 'fr',
    Fy: 'fy',
    Ga: 'ga',
    Gd: 'gd',
    Gl: 'gl',
    He: 'he',
    Hi: 'hi',
    Hr: 'hr',
    Hsb: 'hsb',
    Hu: 'hu',
    Hy: 'hy',
    Ia: 'ia',
    Id: 'id',
    Ig: 'ig',
    Io: 'io',
    Is: 'is',
    It: 'it',
    Ja: 'ja',
    Ka: 'ka',
    Kab: 'kab',
    Kk: 'kk',
    Km: 'km',
    Kn: 'kn',
    Ko: 'ko',
    Ky: 'ky',
    Lb: 'lb',
    Lt: 'lt',
    Lv: 'lv',
    Mk: 'mk',
    Ml: 'ml',
    Mn: 'mn',
    Mr: 'mr',
    Ms: 'ms',
    My: 'my',
    Nb: 'nb',
    Ne: 'ne',
    Nl: 'nl',
    Nn: 'nn',
    Os: 'os',
    Pa: 'pa',
    Pl: 'pl',
    Pt: 'pt',
    PtBr: 'pt-br',
    Ro: 'ro',
    Ru: 'ru',
    Sk: 'sk',
    Sl: 'sl',
    Sq: 'sq',
    Sr: 'sr',
    SrLatn: 'sr-latn',
    Sv: 'sv',
    Sw: 'sw',
    Ta: 'ta',
    Te: 'te',
    Tg: 'tg',
    Th: 'th',
    Tk: 'tk',
    Tr: 'tr',
    Tt: 'tt',
    Udm: 'udm',
    Ug: 'ug',
    Uk: 'uk',
    Ur: 'ur',
    Uz: 'uz',
    Vi: 'vi',
    ZhHans: 'zh-hans',
    ZhHant: 'zh-hant'
} as const;
export type SchemaRetrieveLangEnum = typeof SchemaRetrieveLangEnum[keyof typeof SchemaRetrieveLangEnum];


/**
 * StudentGradesApi - axios parameter creator
 * @export
 */
export const StudentGradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {StudentGrade} studentGrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesCreate: async (studentGrade: StudentGrade, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentGrade' is not null or undefined
            assertParamExists('studentGradesCreate', 'studentGrade', studentGrade)
            const localVarPath = `/student_grades/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studentGrade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesDestroy: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studentGradesDestroy', 'id', id)
            const localVarPath = `/student_grades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/student_grades/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {PatchedStudentGrade} [patchedStudentGrade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesPartialUpdate: async (id: string, patchedStudentGrade?: PatchedStudentGrade, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studentGradesPartialUpdate', 'id', id)
            const localVarPath = `/student_grades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStudentGrade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesRetrieve: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studentGradesRetrieve', 'id', id)
            const localVarPath = `/student_grades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {StudentGrade} studentGrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesUpdate: async (id: string, studentGrade: StudentGrade, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studentGradesUpdate', 'id', id)
            // verify required parameter 'studentGrade' is not null or undefined
            assertParamExists('studentGradesUpdate', 'studentGrade', studentGrade)
            const localVarPath = `/student_grades/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studentGrade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentGradesApi - functional programming interface
 * @export
 */
export const StudentGradesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentGradesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {StudentGrade} studentGrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentGradesCreate(studentGrade: StudentGrade, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesCreate(studentGrade, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentGradesApi.studentGradesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentGradesDestroy(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentGradesApi.studentGradesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentGradesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudentGrade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentGradesApi.studentGradesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {PatchedStudentGrade} [patchedStudentGrade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentGradesPartialUpdate(id: string, patchedStudentGrade?: PatchedStudentGrade, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesPartialUpdate(id, patchedStudentGrade, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentGradesApi.studentGradesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentGradesRetrieve(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentGradesApi.studentGradesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {StudentGrade} studentGrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentGradesUpdate(id: string, studentGrade: StudentGrade, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesUpdate(id, studentGrade, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StudentGradesApi.studentGradesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StudentGradesApi - factory interface
 * @export
 */
export const StudentGradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentGradesApiFp(configuration)
    return {
        /**
         * 
         * @param {StudentGrade} studentGrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesCreate(studentGrade: StudentGrade, options?: RawAxiosRequestConfig): AxiosPromise<StudentGrade> {
            return localVarFp.studentGradesCreate(studentGrade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.studentGradesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<StudentGrade>> {
            return localVarFp.studentGradesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {PatchedStudentGrade} [patchedStudentGrade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesPartialUpdate(id: string, patchedStudentGrade?: PatchedStudentGrade, options?: RawAxiosRequestConfig): AxiosPromise<StudentGrade> {
            return localVarFp.studentGradesPartialUpdate(id, patchedStudentGrade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StudentGrade> {
            return localVarFp.studentGradesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this student grade.
         * @param {StudentGrade} studentGrade 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentGradesUpdate(id: string, studentGrade: StudentGrade, options?: RawAxiosRequestConfig): AxiosPromise<StudentGrade> {
            return localVarFp.studentGradesUpdate(id, studentGrade, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentGradesApi - object-oriented interface
 * @export
 * @class StudentGradesApi
 * @extends {BaseAPI}
 */
export class StudentGradesApi extends BaseAPI {
    /**
     * 
     * @param {StudentGrade} studentGrade 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentGradesApi
     */
    public studentGradesCreate(studentGrade: StudentGrade, options?: RawAxiosRequestConfig) {
        return StudentGradesApiFp(this.configuration).studentGradesCreate(studentGrade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this student grade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentGradesApi
     */
    public studentGradesDestroy(id: string, options?: RawAxiosRequestConfig) {
        return StudentGradesApiFp(this.configuration).studentGradesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentGradesApi
     */
    public studentGradesList(options?: RawAxiosRequestConfig) {
        return StudentGradesApiFp(this.configuration).studentGradesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this student grade.
     * @param {PatchedStudentGrade} [patchedStudentGrade] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentGradesApi
     */
    public studentGradesPartialUpdate(id: string, patchedStudentGrade?: PatchedStudentGrade, options?: RawAxiosRequestConfig) {
        return StudentGradesApiFp(this.configuration).studentGradesPartialUpdate(id, patchedStudentGrade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this student grade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentGradesApi
     */
    public studentGradesRetrieve(id: string, options?: RawAxiosRequestConfig) {
        return StudentGradesApiFp(this.configuration).studentGradesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this student grade.
     * @param {StudentGrade} studentGrade 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentGradesApi
     */
    public studentGradesUpdate(id: string, studentGrade: StudentGrade, options?: RawAxiosRequestConfig) {
        return StudentGradesApiFp(this.configuration).studentGradesUpdate(id, studentGrade, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: async (user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCreate', 'user', user)
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDestroy', 'id', id)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (id: number, patchedUser?: PatchedUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPartialUpdate', 'id', id)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRetrieve', 'id', id)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: number, user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersUpdate', 'user', user)
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CsrfExemptSessionAuthentication required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreate(user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(id, patchedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: number, user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(user: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersCreate(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.usersList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersPartialUpdate(id, patchedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: number, user: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersUpdate(id, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreate(user: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCreate(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDestroy(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersList(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUser} [patchedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPartialUpdate(id, patchedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: number, user: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdate(id, user, options).then((request) => request(this.axios, this.basePath));
    }
}



