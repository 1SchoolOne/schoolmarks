/* tslint:disable */

/* eslint-disable */

/**
 * No description provided (generated by Openapi Generator
 * https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */
import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'

import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequiredError, operationServerMap } from './base'
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	createRequestFunction,
	serializeDataIfNeeded,
	setSearchParams,
	toPathString,
} from './common'
import type { Configuration } from './configuration'

/**
 * @export
 * @interface AttendanceDetail
 */
export interface AttendanceDetail {
	/**
	 * @memberof AttendanceDetail
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof AttendanceDetail
	 * @type {string}
	 */
	attendance_record: string
	/**
	 * @memberof AttendanceDetail
	 * @type {number}
	 */
	student: number
	/**
	 * @memberof AttendanceDetail
	 * @type {string}
	 */
	class_session: string
	/**
	 * @memberof AttendanceDetail
	 * @type {string}
	 */
	course: string
	/**
	 * @memberof AttendanceDetail
	 * @type {string}
	 */
	status: string
	/**
	 * @memberof AttendanceDetail
	 * @type {string}
	 */
	checked_in_at: string
	/**
	 * @memberof AttendanceDetail
	 * @type {number}
	 */
	minutes_late: number
	/**
	 * @memberof AttendanceDetail
	 * @type {string}
	 */
	created_at: string
}
/**
 * @export
 * @interface AttendanceRecord
 */
export interface AttendanceRecord {
	/**
	 * @memberof AttendanceRecord
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof AttendanceRecord
	 * @type {string}
	 */
	checkin_session: string
	/**
	 * @memberof AttendanceRecord
	 * @type {number}
	 */
	student: number
	/**
	 * @memberof AttendanceRecord
	 * @type {User}
	 */
	student_detail: User
	/**
	 * @memberof AttendanceRecord
	 * @type {string}
	 */
	checked_in_at: string
	/**
	 * @memberof AttendanceRecord
	 * @type {string}
	 */
	status: string
}
/**
 * @export
 * @interface CheckinSession
 */
export interface CheckinSession {
	/**
	 * @memberof CheckinSession
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof CheckinSession
	 * @type {string}
	 */
	class_session: string
	/**
	 * @memberof CheckinSession
	 * @type {string}
	 */
	started_at: string
	/**
	 * @memberof CheckinSession
	 * @type {string}
	 */
	closed_at: string
	/**
	 * @memberof CheckinSession
	 * @type {number}
	 */
	created_by: number
	/**
	 * @memberof CheckinSession
	 * @type {string}
	 */
	status: string
	/**
	 * @memberof CheckinSession
	 * @type {string}
	 */
	secret?: string | null
}
/**
 * @export
 * @interface Class
 */
export interface Class {
	/**
	 * @memberof Class
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof Class
	 * @type {User[]}
	 */
	students: Array<User>
	/**
	 * @memberof Class
	 * @type {string}
	 */
	name: string
	/**
	 * @memberof Class
	 * @type {string}
	 */
	code: string
	/**
	 * @memberof Class
	 * @type {number}
	 */
	year_of_graduation?: number | null
	/**
	 * @memberof Class
	 * @type {string}
	 */
	created_at: string
	/**
	 * @memberof Class
	 * @type {string}
	 */
	updated_at: string
}
/**
 * @export
 * @interface ClassSession
 */
export interface ClassSession {
	/**
	 * @memberof ClassSession
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof ClassSession
	 * @type {string}
	 */
	course: string
	/**
	 * @memberof ClassSession
	 * @type {string}
	 */
	date: string
	/**
	 * @memberof ClassSession
	 * @type {string}
	 */
	start_time: string
	/**
	 * @memberof ClassSession
	 * @type {string}
	 */
	end_time: string
	/**
	 * @memberof ClassSession
	 * @type {string}
	 */
	room: string
	/**
	 * @memberof ClassSession
	 * @type {string}
	 */
	status: string
}
/**
 * @export
 * @interface ClassSessionDetail
 */
export interface ClassSessionDetail {
	/**
	 * @memberof ClassSessionDetail
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof ClassSessionDetail
	 * @type {Course}
	 */
	course: Course
	/**
	 * @memberof ClassSessionDetail
	 * @type {string}
	 */
	date: string
	/**
	 * @memberof ClassSessionDetail
	 * @type {string}
	 */
	start_time: string
	/**
	 * @memberof ClassSessionDetail
	 * @type {string}
	 */
	end_time: string
	/**
	 * @memberof ClassSessionDetail
	 * @type {string}
	 */
	room: string
	/**
	 * @memberof ClassSessionDetail
	 * @type {string}
	 */
	status: string
	/**
	 * @memberof ClassSessionDetail
	 * @type {CheckinSession}
	 */
	checkin_session: CheckinSession
}
/**
 * @export
 * @interface ClassStudent
 */
export interface ClassStudent {
	/**
	 * @memberof ClassStudent
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof ClassStudent
	 * @type {string}
	 */
	class_group: string
	/**
	 * @memberof ClassStudent
	 * @type {number}
	 */
	student: number
}
/**
 * @export
 * @interface Course
 */
export interface Course {
	/**
	 * @memberof Course
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof Course
	 * @type {string}
	 */
	name: string
	/**
	 * @memberof Course
	 * @type {string}
	 */
	code: string
	/**
	 * @memberof Course
	 * @type {User}
	 */
	professor: User
	/**
	 * @memberof Course
	 * @type {number}
	 */
	professor_id?: number | null
	/**
	 * @memberof Course
	 * @type {string}
	 */
	created_at: string
	/**
	 * @memberof Course
	 * @type {string}
	 */
	updated_at: string
}
/**
 * @export
 * @interface CourseEnrollment
 */
export interface CourseEnrollment {
	/**
	 * @memberof CourseEnrollment
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof CourseEnrollment
	 * @type {string}
	 */
	course_id: string
	/**
	 * @memberof CourseEnrollment
	 * @type {string}
	 */
	class_group_id: string
	/**
	 * @memberof CourseEnrollment
	 * @type {Course}
	 */
	course: Course
	/**
	 * @memberof CourseEnrollment
	 * @type {Class}
	 */
	class_group: Class
	/**
	 * @memberof CourseEnrollment
	 * @type {string}
	 */
	enrolled_at: string
}
/**
 * @export
 * @interface CreateImportResponse
 */
export interface CreateImportResponse {
	/**
	 * @memberof CreateImportResponse
	 * @type {string}
	 */
	import_id: string
	/**
	 * @memberof CreateImportResponse
	 * @type {StatusEnum}
	 */
	status: StatusEnum
}

/**
 * @export
 * @interface Grade
 */
export interface Grade {
	/**
	 * @memberof Grade
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof Grade
	 * @type {string}
	 */
	course: string
	/**
	 * @memberof Grade
	 * @type {string}
	 */
	name: string
	/**
	 * @memberof Grade
	 * @type {string}
	 */
	max_value: string
	/**
	 * Pourcentage de la note finale
	 *
	 * @memberof Grade
	 * @type {string}
	 */
	coef: string
	/**
	 * @memberof Grade
	 * @type {string}
	 */
	description?: string | null
	/**
	 * @memberof Grade
	 * @type {Class}
	 */
	class_group: Class
	/**
	 * @memberof Grade
	 * @type {StudentGrade[]}
	 */
	student_grades: Array<StudentGrade>
	/**
	 * @memberof Grade
	 * @type {string}
	 */
	created_at: string
	/**
	 * @memberof Grade
	 * @type {string}
	 */
	updated_at: string
}
/**
 * @export
 * @interface Import
 */
export interface Import {
	/**
	 * @memberof Import
	 * @type {string}
	 */
	file: string
}
/**
 * @export
 * @interface ImportStatus
 */
export interface ImportStatus {
	/**
	 * @memberof ImportStatus
	 * @type {string}
	 */
	import_id: string
	/**
	 * @memberof ImportStatus
	 * @type {TypeEnum}
	 */
	type: TypeEnum
	/**
	 * @memberof ImportStatus
	 * @type {StatusEnum}
	 */
	status: StatusEnum
	/**
	 * @memberof ImportStatus
	 * @type {number}
	 */
	progress: number
	/**
	 * @memberof ImportStatus
	 * @type {string}
	 */
	imported_by: string
	/**
	 * @memberof ImportStatus
	 * @type {any}
	 */
	results?: any
	/**
	 * @memberof ImportStatus
	 * @type {string}
	 */
	error?: string | null
	/**
	 * @memberof ImportStatus
	 * @type {string[]}
	 */
	warnings?: Array<string> | null
	/**
	 * @memberof ImportStatus
	 * @type {string}
	 */
	finished_at: string
	/**
	 * @memberof ImportStatus
	 * @type {string}
	 */
	started_at: string
}

/**
 * @export
 * @interface PatchedAttendanceDetail
 */
export interface PatchedAttendanceDetail {
	/**
	 * @memberof PatchedAttendanceDetail
	 * @type {string}
	 */
	id?: string
	/**
	 * @memberof PatchedAttendanceDetail
	 * @type {string}
	 */
	attendance_record?: string
	/**
	 * @memberof PatchedAttendanceDetail
	 * @type {number}
	 */
	student?: number
	/**
	 * @memberof PatchedAttendanceDetail
	 * @type {string}
	 */
	class_session?: string
	/**
	 * @memberof PatchedAttendanceDetail
	 * @type {string}
	 */
	course?: string
	/**
	 * @memberof PatchedAttendanceDetail
	 * @type {string}
	 */
	status?: string
	/**
	 * @memberof PatchedAttendanceDetail
	 * @type {string}
	 */
	checked_in_at?: string
	/**
	 * @memberof PatchedAttendanceDetail
	 * @type {number}
	 */
	minutes_late?: number
	/**
	 * @memberof PatchedAttendanceDetail
	 * @type {string}
	 */
	created_at?: string
}
/**
 * @export
 * @interface PatchedAttendanceRecord
 */
export interface PatchedAttendanceRecord {
	/**
	 * @memberof PatchedAttendanceRecord
	 * @type {string}
	 */
	id?: string
	/**
	 * @memberof PatchedAttendanceRecord
	 * @type {string}
	 */
	checkin_session?: string
	/**
	 * @memberof PatchedAttendanceRecord
	 * @type {number}
	 */
	student?: number
	/**
	 * @memberof PatchedAttendanceRecord
	 * @type {User}
	 */
	student_detail?: User
	/**
	 * @memberof PatchedAttendanceRecord
	 * @type {string}
	 */
	checked_in_at?: string
	/**
	 * @memberof PatchedAttendanceRecord
	 * @type {string}
	 */
	status?: string
}
/**
 * @export
 * @interface PatchedCheckinSession
 */
export interface PatchedCheckinSession {
	/**
	 * @memberof PatchedCheckinSession
	 * @type {string}
	 */
	id?: string
	/**
	 * @memberof PatchedCheckinSession
	 * @type {string}
	 */
	class_session?: string
	/**
	 * @memberof PatchedCheckinSession
	 * @type {string}
	 */
	started_at?: string
	/**
	 * @memberof PatchedCheckinSession
	 * @type {string}
	 */
	closed_at?: string
	/**
	 * @memberof PatchedCheckinSession
	 * @type {number}
	 */
	created_by?: number
	/**
	 * @memberof PatchedCheckinSession
	 * @type {string}
	 */
	status?: string
	/**
	 * @memberof PatchedCheckinSession
	 * @type {string}
	 */
	secret?: string | null
}
/**
 * @export
 * @interface PatchedClass
 */
export interface PatchedClass {
	/**
	 * @memberof PatchedClass
	 * @type {string}
	 */
	id?: string
	/**
	 * @memberof PatchedClass
	 * @type {User[]}
	 */
	students?: Array<User>
	/**
	 * @memberof PatchedClass
	 * @type {string}
	 */
	name?: string
	/**
	 * @memberof PatchedClass
	 * @type {string}
	 */
	code?: string
	/**
	 * @memberof PatchedClass
	 * @type {number}
	 */
	year_of_graduation?: number | null
	/**
	 * @memberof PatchedClass
	 * @type {string}
	 */
	created_at?: string
	/**
	 * @memberof PatchedClass
	 * @type {string}
	 */
	updated_at?: string
}
/**
 * @export
 * @interface PatchedClassSessionDetail
 */
export interface PatchedClassSessionDetail {
	/**
	 * @memberof PatchedClassSessionDetail
	 * @type {string}
	 */
	id?: string
	/**
	 * @memberof PatchedClassSessionDetail
	 * @type {Course}
	 */
	course?: Course
	/**
	 * @memberof PatchedClassSessionDetail
	 * @type {string}
	 */
	date?: string
	/**
	 * @memberof PatchedClassSessionDetail
	 * @type {string}
	 */
	start_time?: string
	/**
	 * @memberof PatchedClassSessionDetail
	 * @type {string}
	 */
	end_time?: string
	/**
	 * @memberof PatchedClassSessionDetail
	 * @type {string}
	 */
	room?: string
	/**
	 * @memberof PatchedClassSessionDetail
	 * @type {string}
	 */
	status?: string
	/**
	 * @memberof PatchedClassSessionDetail
	 * @type {CheckinSession}
	 */
	checkin_session?: CheckinSession
}
/**
 * @export
 * @interface PatchedClassStudent
 */
export interface PatchedClassStudent {
	/**
	 * @memberof PatchedClassStudent
	 * @type {string}
	 */
	id?: string
	/**
	 * @memberof PatchedClassStudent
	 * @type {string}
	 */
	class_group?: string
	/**
	 * @memberof PatchedClassStudent
	 * @type {number}
	 */
	student?: number
}
/**
 * @export
 * @interface PatchedCourse
 */
export interface PatchedCourse {
	/**
	 * @memberof PatchedCourse
	 * @type {string}
	 */
	id?: string
	/**
	 * @memberof PatchedCourse
	 * @type {string}
	 */
	name?: string
	/**
	 * @memberof PatchedCourse
	 * @type {string}
	 */
	code?: string
	/**
	 * @memberof PatchedCourse
	 * @type {User}
	 */
	professor?: User
	/**
	 * @memberof PatchedCourse
	 * @type {number}
	 */
	professor_id?: number | null
	/**
	 * @memberof PatchedCourse
	 * @type {string}
	 */
	created_at?: string
	/**
	 * @memberof PatchedCourse
	 * @type {string}
	 */
	updated_at?: string
}
/**
 * @export
 * @interface PatchedCourseEnrollment
 */
export interface PatchedCourseEnrollment {
	/**
	 * @memberof PatchedCourseEnrollment
	 * @type {string}
	 */
	id?: string
	/**
	 * @memberof PatchedCourseEnrollment
	 * @type {string}
	 */
	course_id?: string
	/**
	 * @memberof PatchedCourseEnrollment
	 * @type {string}
	 */
	class_group_id?: string
	/**
	 * @memberof PatchedCourseEnrollment
	 * @type {Course}
	 */
	course?: Course
	/**
	 * @memberof PatchedCourseEnrollment
	 * @type {Class}
	 */
	class_group?: Class
	/**
	 * @memberof PatchedCourseEnrollment
	 * @type {string}
	 */
	enrolled_at?: string
}
/**
 * @export
 * @interface PatchedGrade
 */
export interface PatchedGrade {
	/**
	 * @memberof PatchedGrade
	 * @type {string}
	 */
	id?: string
	/**
	 * @memberof PatchedGrade
	 * @type {string}
	 */
	course?: string
	/**
	 * @memberof PatchedGrade
	 * @type {string}
	 */
	name?: string
	/**
	 * @memberof PatchedGrade
	 * @type {string}
	 */
	max_value?: string
	/**
	 * Pourcentage de la note finale
	 *
	 * @memberof PatchedGrade
	 * @type {string}
	 */
	coef?: string
	/**
	 * @memberof PatchedGrade
	 * @type {string}
	 */
	description?: string | null
	/**
	 * @memberof PatchedGrade
	 * @type {Class}
	 */
	class_group?: Class
	/**
	 * @memberof PatchedGrade
	 * @type {StudentGrade[]}
	 */
	student_grades?: Array<StudentGrade>
	/**
	 * @memberof PatchedGrade
	 * @type {string}
	 */
	created_at?: string
	/**
	 * @memberof PatchedGrade
	 * @type {string}
	 */
	updated_at?: string
}
/**
 * @export
 * @interface PatchedStudentGrade
 */
export interface PatchedStudentGrade {
	/**
	 * @memberof PatchedStudentGrade
	 * @type {string}
	 */
	id?: string
	/**
	 * @memberof PatchedStudentGrade
	 * @type {string}
	 */
	grade?: string
	/**
	 * @memberof PatchedStudentGrade
	 * @type {number}
	 */
	student?: number
	/**
	 * @memberof PatchedStudentGrade
	 * @type {string}
	 */
	value?: string
	/**
	 * @memberof PatchedStudentGrade
	 * @type {string}
	 */
	comment?: string | null
	/**
	 * @memberof PatchedStudentGrade
	 * @type {string}
	 */
	created_at?: string
	/**
	 * @memberof PatchedStudentGrade
	 * @type {string}
	 */
	updated_at?: string
}
/**
 * @export
 * @interface PatchedUser
 */
export interface PatchedUser {
	/**
	 * @memberof PatchedUser
	 * @type {number}
	 */
	id?: number
	/**
	 * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
	 *
	 * @memberof PatchedUser
	 * @type {string}
	 */
	username?: string
	/**
	 * @memberof PatchedUser
	 * @type {string}
	 */
	first_name?: string
	/**
	 * @memberof PatchedUser
	 * @type {string}
	 */
	last_name?: string
	/**
	 * @memberof PatchedUser
	 * @type {string}
	 */
	email?: string
	/**
	 * @memberof PatchedUser
	 * @type {string}
	 */
	birthday?: string | null
	/**
	 * @memberof PatchedUser
	 * @type {string}
	 */
	phone_number?: string | null
	/**
	 * @memberof PatchedUser
	 * @type {boolean}
	 */
	has_changed_password?: boolean
	/**
	 * @memberof PatchedUser
	 * @type {RoleEnum}
	 */
	role?: RoleEnum
	/**
	 * @memberof PatchedUser
	 * @type {UserRoleEnum}
	 */
	user_role?: UserRoleEnum
}

/**
 * @export
 * @enum {string}
 */

export const RoleEnum = {
	Admin: 'admin',
	Teacher: 'teacher',
	Student: 'student',
} as const

export type RoleEnum = (typeof RoleEnum)[keyof typeof RoleEnum]

/**
 * - `processing` - processing * `completed` - completed * `failed` - failed
 *
 * @export
 * @enum {string}
 */

export const StatusEnum = {
	Processing: 'processing',
	Completed: 'completed',
	Failed: 'failed',
} as const

export type StatusEnum = (typeof StatusEnum)[keyof typeof StatusEnum]

/**
 * @export
 * @interface StudentGrade
 */
export interface StudentGrade {
	/**
	 * @memberof StudentGrade
	 * @type {string}
	 */
	id: string
	/**
	 * @memberof StudentGrade
	 * @type {string}
	 */
	grade: string
	/**
	 * @memberof StudentGrade
	 * @type {number}
	 */
	student: number
	/**
	 * @memberof StudentGrade
	 * @type {string}
	 */
	value: string
	/**
	 * @memberof StudentGrade
	 * @type {string}
	 */
	comment?: string | null
	/**
	 * @memberof StudentGrade
	 * @type {string}
	 */
	created_at: string
	/**
	 * @memberof StudentGrade
	 * @type {string}
	 */
	updated_at: string
}
/**
 * - `users` - users * `classes` - classes * `courses` - courses
 *
 * @export
 * @enum {string}
 */

export const TypeEnum = {
	Users: 'users',
	Classes: 'classes',
	Courses: 'courses',
} as const

export type TypeEnum = (typeof TypeEnum)[keyof typeof TypeEnum]

/**
 * @export
 * @interface User
 */
export interface User {
	/**
	 * @memberof User
	 * @type {number}
	 */
	id: number
	/**
	 * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
	 *
	 * @memberof User
	 * @type {string}
	 */
	username: string
	/**
	 * @memberof User
	 * @type {string}
	 */
	first_name?: string
	/**
	 * @memberof User
	 * @type {string}
	 */
	last_name?: string
	/**
	 * @memberof User
	 * @type {string}
	 */
	email: string
	/**
	 * @memberof User
	 * @type {string}
	 */
	birthday?: string | null
	/**
	 * @memberof User
	 * @type {string}
	 */
	phone_number?: string | null
	/**
	 * @memberof User
	 * @type {boolean}
	 */
	has_changed_password?: boolean
	/**
	 * @memberof User
	 * @type {RoleEnum}
	 */
	role: RoleEnum
	/**
	 * @memberof User
	 * @type {UserRoleEnum}
	 */
	user_role: UserRoleEnum
}

/**
 * - `student` - student * `teacher` - teacher * `admin` - admin
 *
 * @export
 * @enum {string}
 */

export const UserRoleEnum = {
	Student: 'student',
	Teacher: 'teacher',
	Admin: 'admin',
} as const

export type UserRoleEnum = (typeof UserRoleEnum)[keyof typeof UserRoleEnum]

/**
 * AttendanceDetailsApi - axios parameter creator
 *
 * @export
 */
export const AttendanceDetailsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {AttendanceDetail} attendanceDetail
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsCreate: async (
			attendanceDetail: AttendanceDetail,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'attendanceDetail' is not null or undefined
			assertParamExists('attendanceDetailsCreate', 'attendanceDetail', attendanceDetail)
			const localVarPath = `/attendance_details/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				attendanceDetail,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsDestroy: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('attendanceDetailsDestroy', 'id', id)
			const localVarPath = `/attendance_details/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/attendance_details/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {PatchedAttendanceDetail} [patchedAttendanceDetail]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsPartialUpdate: async (
			id: string,
			patchedAttendanceDetail?: PatchedAttendanceDetail,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('attendanceDetailsPartialUpdate', 'id', id)
			const localVarPath = `/attendance_details/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedAttendanceDetail,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('attendanceDetailsRetrieve', 'id', id)
			const localVarPath = `/attendance_details/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {AttendanceDetail} attendanceDetail
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsUpdate: async (
			id: string,
			attendanceDetail: AttendanceDetail,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('attendanceDetailsUpdate', 'id', id)
			// verify required parameter 'attendanceDetail' is not null or undefined
			assertParamExists('attendanceDetailsUpdate', 'attendanceDetail', attendanceDetail)
			const localVarPath = `/attendance_details/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				attendanceDetail,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * AttendanceDetailsApi - functional programming interface
 *
 * @export
 */
export const AttendanceDetailsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = AttendanceDetailsApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {AttendanceDetail} attendanceDetail
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceDetailsCreate(
			attendanceDetail: AttendanceDetail,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceDetail>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsCreate(
				attendanceDetail,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceDetailsApi.attendanceDetailsCreate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceDetailsDestroy(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsDestroy(
				id,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceDetailsApi.attendanceDetailsDestroy']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceDetailsList(
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttendanceDetail>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceDetailsApi.attendanceDetailsList']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {PatchedAttendanceDetail} [patchedAttendanceDetail]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceDetailsPartialUpdate(
			id: string,
			patchedAttendanceDetail?: PatchedAttendanceDetail,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceDetail>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsPartialUpdate(
				id,
				patchedAttendanceDetail,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceDetailsApi.attendanceDetailsPartialUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceDetailsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceDetail>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsRetrieve(
				id,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceDetailsApi.attendanceDetailsRetrieve']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {AttendanceDetail} attendanceDetail
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceDetailsUpdate(
			id: string,
			attendanceDetail: AttendanceDetail,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceDetail>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceDetailsUpdate(
				id,
				attendanceDetail,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceDetailsApi.attendanceDetailsUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * AttendanceDetailsApi - factory interface
 *
 * @export
 */
export const AttendanceDetailsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = AttendanceDetailsApiFp(configuration)
	return {
		/**
		 * @param {AttendanceDetail} attendanceDetail
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsCreate(
			attendanceDetail: AttendanceDetail,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AttendanceDetail> {
			return localVarFp
				.attendanceDetailsCreate(attendanceDetail, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp
				.attendanceDetailsDestroy(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<AttendanceDetail>> {
			return localVarFp.attendanceDetailsList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {PatchedAttendanceDetail} [patchedAttendanceDetail]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsPartialUpdate(
			id: string,
			patchedAttendanceDetail?: PatchedAttendanceDetail,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AttendanceDetail> {
			return localVarFp
				.attendanceDetailsPartialUpdate(id, patchedAttendanceDetail, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AttendanceDetail> {
			return localVarFp
				.attendanceDetailsRetrieve(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this attendance detail.
		 * @param {AttendanceDetail} attendanceDetail
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceDetailsUpdate(
			id: string,
			attendanceDetail: AttendanceDetail,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AttendanceDetail> {
			return localVarFp
				.attendanceDetailsUpdate(id, attendanceDetail, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * AttendanceDetailsApi - object-oriented interface
 *
 * @class AttendanceDetailsApi
 * @extends {BaseAPI}
 * @export
 */
export class AttendanceDetailsApi extends BaseAPI {
	/**
	 * @memberof AttendanceDetailsApi
	 * @param {AttendanceDetail} attendanceDetail
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceDetailsCreate(
		attendanceDetail: AttendanceDetail,
		options?: RawAxiosRequestConfig,
	) {
		return AttendanceDetailsApiFp(this.configuration)
			.attendanceDetailsCreate(attendanceDetail, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof AttendanceDetailsApi
	 * @param {string} id A UUID string identifying this attendance detail.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceDetailsDestroy(id: string, options?: RawAxiosRequestConfig) {
		return AttendanceDetailsApiFp(this.configuration)
			.attendanceDetailsDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof AttendanceDetailsApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceDetailsList(options?: RawAxiosRequestConfig) {
		return AttendanceDetailsApiFp(this.configuration)
			.attendanceDetailsList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof AttendanceDetailsApi
	 * @param {string} id A UUID string identifying this attendance detail.
	 * @param {PatchedAttendanceDetail} [patchedAttendanceDetail]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceDetailsPartialUpdate(
		id: string,
		patchedAttendanceDetail?: PatchedAttendanceDetail,
		options?: RawAxiosRequestConfig,
	) {
		return AttendanceDetailsApiFp(this.configuration)
			.attendanceDetailsPartialUpdate(id, patchedAttendanceDetail, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof AttendanceDetailsApi
	 * @param {string} id A UUID string identifying this attendance detail.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceDetailsRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return AttendanceDetailsApiFp(this.configuration)
			.attendanceDetailsRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof AttendanceDetailsApi
	 * @param {string} id A UUID string identifying this attendance detail.
	 * @param {AttendanceDetail} attendanceDetail
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceDetailsUpdate(
		id: string,
		attendanceDetail: AttendanceDetail,
		options?: RawAxiosRequestConfig,
	) {
		return AttendanceDetailsApiFp(this.configuration)
			.attendanceDetailsUpdate(id, attendanceDetail, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * AttendanceRecordsApi - axios parameter creator
 *
 * @export
 */
export const AttendanceRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {AttendanceRecord} attendanceRecord
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsCreate: async (
			attendanceRecord: AttendanceRecord,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'attendanceRecord' is not null or undefined
			assertParamExists('attendanceRecordsCreate', 'attendanceRecord', attendanceRecord)
			const localVarPath = `/attendance_records/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				attendanceRecord,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsDestroy: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('attendanceRecordsDestroy', 'id', id)
			const localVarPath = `/attendance_records/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/attendance_records/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {PatchedAttendanceRecord} [patchedAttendanceRecord]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsPartialUpdate: async (
			id: string,
			patchedAttendanceRecord?: PatchedAttendanceRecord,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('attendanceRecordsPartialUpdate', 'id', id)
			const localVarPath = `/attendance_records/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedAttendanceRecord,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('attendanceRecordsRetrieve', 'id', id)
			const localVarPath = `/attendance_records/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {AttendanceRecord} attendanceRecord
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsUpdate: async (
			id: string,
			attendanceRecord: AttendanceRecord,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('attendanceRecordsUpdate', 'id', id)
			// verify required parameter 'attendanceRecord' is not null or undefined
			assertParamExists('attendanceRecordsUpdate', 'attendanceRecord', attendanceRecord)
			const localVarPath = `/attendance_records/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				attendanceRecord,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * AttendanceRecordsApi - functional programming interface
 *
 * @export
 */
export const AttendanceRecordsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = AttendanceRecordsApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {AttendanceRecord} attendanceRecord
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceRecordsCreate(
			attendanceRecord: AttendanceRecord,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceRecord>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsCreate(
				attendanceRecord,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceRecordsApi.attendanceRecordsCreate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceRecordsDestroy(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsDestroy(
				id,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceRecordsApi.attendanceRecordsDestroy']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceRecordsList(
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttendanceRecord>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceRecordsApi.attendanceRecordsList']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {PatchedAttendanceRecord} [patchedAttendanceRecord]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceRecordsPartialUpdate(
			id: string,
			patchedAttendanceRecord?: PatchedAttendanceRecord,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceRecord>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsPartialUpdate(
				id,
				patchedAttendanceRecord,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceRecordsApi.attendanceRecordsPartialUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceRecordsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceRecord>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsRetrieve(
				id,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceRecordsApi.attendanceRecordsRetrieve']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {AttendanceRecord} attendanceRecord
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attendanceRecordsUpdate(
			id: string,
			attendanceRecord: AttendanceRecord,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttendanceRecord>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.attendanceRecordsUpdate(
				id,
				attendanceRecord,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AttendanceRecordsApi.attendanceRecordsUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * AttendanceRecordsApi - factory interface
 *
 * @export
 */
export const AttendanceRecordsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = AttendanceRecordsApiFp(configuration)
	return {
		/**
		 * @param {AttendanceRecord} attendanceRecord
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsCreate(
			attendanceRecord: AttendanceRecord,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AttendanceRecord> {
			return localVarFp
				.attendanceRecordsCreate(attendanceRecord, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp
				.attendanceRecordsDestroy(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<AttendanceRecord>> {
			return localVarFp.attendanceRecordsList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {PatchedAttendanceRecord} [patchedAttendanceRecord]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsPartialUpdate(
			id: string,
			patchedAttendanceRecord?: PatchedAttendanceRecord,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AttendanceRecord> {
			return localVarFp
				.attendanceRecordsPartialUpdate(id, patchedAttendanceRecord, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AttendanceRecord> {
			return localVarFp
				.attendanceRecordsRetrieve(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this attendance record.
		 * @param {AttendanceRecord} attendanceRecord
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attendanceRecordsUpdate(
			id: string,
			attendanceRecord: AttendanceRecord,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AttendanceRecord> {
			return localVarFp
				.attendanceRecordsUpdate(id, attendanceRecord, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * AttendanceRecordsApi - object-oriented interface
 *
 * @class AttendanceRecordsApi
 * @extends {BaseAPI}
 * @export
 */
export class AttendanceRecordsApi extends BaseAPI {
	/**
	 * @memberof AttendanceRecordsApi
	 * @param {AttendanceRecord} attendanceRecord
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceRecordsCreate(
		attendanceRecord: AttendanceRecord,
		options?: RawAxiosRequestConfig,
	) {
		return AttendanceRecordsApiFp(this.configuration)
			.attendanceRecordsCreate(attendanceRecord, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof AttendanceRecordsApi
	 * @param {string} id A UUID string identifying this attendance record.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceRecordsDestroy(id: string, options?: RawAxiosRequestConfig) {
		return AttendanceRecordsApiFp(this.configuration)
			.attendanceRecordsDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof AttendanceRecordsApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceRecordsList(options?: RawAxiosRequestConfig) {
		return AttendanceRecordsApiFp(this.configuration)
			.attendanceRecordsList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof AttendanceRecordsApi
	 * @param {string} id A UUID string identifying this attendance record.
	 * @param {PatchedAttendanceRecord} [patchedAttendanceRecord]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceRecordsPartialUpdate(
		id: string,
		patchedAttendanceRecord?: PatchedAttendanceRecord,
		options?: RawAxiosRequestConfig,
	) {
		return AttendanceRecordsApiFp(this.configuration)
			.attendanceRecordsPartialUpdate(id, patchedAttendanceRecord, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof AttendanceRecordsApi
	 * @param {string} id A UUID string identifying this attendance record.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceRecordsRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return AttendanceRecordsApiFp(this.configuration)
			.attendanceRecordsRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof AttendanceRecordsApi
	 * @param {string} id A UUID string identifying this attendance record.
	 * @param {AttendanceRecord} attendanceRecord
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public attendanceRecordsUpdate(
		id: string,
		attendanceRecord: AttendanceRecord,
		options?: RawAxiosRequestConfig,
	) {
		return AttendanceRecordsApiFp(this.configuration)
			.attendanceRecordsUpdate(id, attendanceRecord, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * CheckinSessionsApi - axios parameter creator
 *
 * @export
 */
export const CheckinSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {CheckinSession} checkinSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsCreate: async (
			checkinSession: CheckinSession,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'checkinSession' is not null or undefined
			assertParamExists('checkinSessionsCreate', 'checkinSession', checkinSession)
			const localVarPath = `/checkin_sessions/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				checkinSession,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsDestroy: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('checkinSessionsDestroy', 'id', id)
			const localVarPath = `/checkin_sessions/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/checkin_sessions/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {PatchedCheckinSession} [patchedCheckinSession]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsPartialUpdate: async (
			id: string,
			patchedCheckinSession?: PatchedCheckinSession,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('checkinSessionsPartialUpdate', 'id', id)
			const localVarPath = `/checkin_sessions/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedCheckinSession,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('checkinSessionsRetrieve', 'id', id)
			const localVarPath = `/checkin_sessions/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsTotpRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('checkinSessionsTotpRetrieve', 'id', id)
			const localVarPath = `/checkin_sessions/{id}/totp/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {CheckinSession} checkinSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsUpdate: async (
			id: string,
			checkinSession: CheckinSession,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('checkinSessionsUpdate', 'id', id)
			// verify required parameter 'checkinSession' is not null or undefined
			assertParamExists('checkinSessionsUpdate', 'checkinSession', checkinSession)
			const localVarPath = `/checkin_sessions/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				checkinSession,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * CheckinSessionsApi - functional programming interface
 *
 * @export
 */
export const CheckinSessionsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = CheckinSessionsApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {CheckinSession} checkinSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async checkinSessionsCreate(
			checkinSession: CheckinSession,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsCreate(
				checkinSession,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CheckinSessionsApi.checkinSessionsCreate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async checkinSessionsDestroy(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsDestroy(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CheckinSessionsApi.checkinSessionsDestroy']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async checkinSessionsList(
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CheckinSession>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CheckinSessionsApi.checkinSessionsList']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {PatchedCheckinSession} [patchedCheckinSession]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async checkinSessionsPartialUpdate(
			id: string,
			patchedCheckinSession?: PatchedCheckinSession,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsPartialUpdate(
				id,
				patchedCheckinSession,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CheckinSessionsApi.checkinSessionsPartialUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async checkinSessionsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsRetrieve(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CheckinSessionsApi.checkinSessionsRetrieve']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async checkinSessionsTotpRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsTotpRetrieve(
				id,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CheckinSessionsApi.checkinSessionsTotpRetrieve']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {CheckinSession} checkinSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async checkinSessionsUpdate(
			id: string,
			checkinSession: CheckinSession,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckinSession>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.checkinSessionsUpdate(
				id,
				checkinSession,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CheckinSessionsApi.checkinSessionsUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * CheckinSessionsApi - factory interface
 *
 * @export
 */
export const CheckinSessionsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = CheckinSessionsApiFp(configuration)
	return {
		/**
		 * @param {CheckinSession} checkinSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsCreate(
			checkinSession: CheckinSession,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CheckinSession> {
			return localVarFp
				.checkinSessionsCreate(checkinSession, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp
				.checkinSessionsDestroy(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CheckinSession>> {
			return localVarFp.checkinSessionsList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {PatchedCheckinSession} [patchedCheckinSession]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsPartialUpdate(
			id: string,
			patchedCheckinSession?: PatchedCheckinSession,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CheckinSession> {
			return localVarFp
				.checkinSessionsPartialUpdate(id, patchedCheckinSession, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CheckinSession> {
			return localVarFp
				.checkinSessionsRetrieve(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsTotpRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CheckinSession> {
			return localVarFp
				.checkinSessionsTotpRetrieve(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this checkin session.
		 * @param {CheckinSession} checkinSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkinSessionsUpdate(
			id: string,
			checkinSession: CheckinSession,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CheckinSession> {
			return localVarFp
				.checkinSessionsUpdate(id, checkinSession, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * CheckinSessionsApi - object-oriented interface
 *
 * @class CheckinSessionsApi
 * @extends {BaseAPI}
 * @export
 */
export class CheckinSessionsApi extends BaseAPI {
	/**
	 * @memberof CheckinSessionsApi
	 * @param {CheckinSession} checkinSession
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public checkinSessionsCreate(checkinSession: CheckinSession, options?: RawAxiosRequestConfig) {
		return CheckinSessionsApiFp(this.configuration)
			.checkinSessionsCreate(checkinSession, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CheckinSessionsApi
	 * @param {string} id A UUID string identifying this checkin session.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public checkinSessionsDestroy(id: string, options?: RawAxiosRequestConfig) {
		return CheckinSessionsApiFp(this.configuration)
			.checkinSessionsDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CheckinSessionsApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public checkinSessionsList(options?: RawAxiosRequestConfig) {
		return CheckinSessionsApiFp(this.configuration)
			.checkinSessionsList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CheckinSessionsApi
	 * @param {string} id A UUID string identifying this checkin session.
	 * @param {PatchedCheckinSession} [patchedCheckinSession]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public checkinSessionsPartialUpdate(
		id: string,
		patchedCheckinSession?: PatchedCheckinSession,
		options?: RawAxiosRequestConfig,
	) {
		return CheckinSessionsApiFp(this.configuration)
			.checkinSessionsPartialUpdate(id, patchedCheckinSession, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CheckinSessionsApi
	 * @param {string} id A UUID string identifying this checkin session.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public checkinSessionsRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return CheckinSessionsApiFp(this.configuration)
			.checkinSessionsRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CheckinSessionsApi
	 * @param {string} id A UUID string identifying this checkin session.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public checkinSessionsTotpRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return CheckinSessionsApiFp(this.configuration)
			.checkinSessionsTotpRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CheckinSessionsApi
	 * @param {string} id A UUID string identifying this checkin session.
	 * @param {CheckinSession} checkinSession
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public checkinSessionsUpdate(
		id: string,
		checkinSession: CheckinSession,
		options?: RawAxiosRequestConfig,
	) {
		return CheckinSessionsApiFp(this.configuration)
			.checkinSessionsUpdate(id, checkinSession, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * ClassSessionsApi - axios parameter creator
 *
 * @export
 */
export const ClassSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {ClassSession} classSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsCreate: async (
			classSession: ClassSession,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'classSession' is not null or undefined
			assertParamExists('classSessionsCreate', 'classSession', classSession)
			const localVarPath = `/class_sessions/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				classSession,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsDestroy: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classSessionsDestroy', 'id', id)
			const localVarPath = `/class_sessions/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/class_sessions/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {PatchedClassSessionDetail} [patchedClassSessionDetail]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsPartialUpdate: async (
			id: string,
			patchedClassSessionDetail?: PatchedClassSessionDetail,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classSessionsPartialUpdate', 'id', id)
			const localVarPath = `/class_sessions/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedClassSessionDetail,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classSessionsRetrieve', 'id', id)
			const localVarPath = `/class_sessions/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {ClassSession} classSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsUpdate: async (
			id: string,
			classSession: ClassSession,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classSessionsUpdate', 'id', id)
			// verify required parameter 'classSession' is not null or undefined
			assertParamExists('classSessionsUpdate', 'classSession', classSession)
			const localVarPath = `/class_sessions/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				classSession,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ClassSessionsApi - functional programming interface
 *
 * @export
 */
export const ClassSessionsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ClassSessionsApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {ClassSession} classSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classSessionsCreate(
			classSession: ClassSession,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSession>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsCreate(
				classSession,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassSessionsApi.classSessionsCreate']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classSessionsDestroy(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsDestroy(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassSessionsApi.classSessionsDestroy']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classSessionsList(
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassSessionDetail>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassSessionsApi.classSessionsList']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {PatchedClassSessionDetail} [patchedClassSessionDetail]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classSessionsPartialUpdate(
			id: string,
			patchedClassSessionDetail?: PatchedClassSessionDetail,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSessionDetail>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsPartialUpdate(
				id,
				patchedClassSessionDetail,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassSessionsApi.classSessionsPartialUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classSessionsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSessionDetail>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsRetrieve(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassSessionsApi.classSessionsRetrieve']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {ClassSession} classSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classSessionsUpdate(
			id: string,
			classSession: ClassSession,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassSession>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classSessionsUpdate(
				id,
				classSession,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassSessionsApi.classSessionsUpdate']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * ClassSessionsApi - factory interface
 *
 * @export
 */
export const ClassSessionsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = ClassSessionsApiFp(configuration)
	return {
		/**
		 * @param {ClassSession} classSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsCreate(
			classSession: ClassSession,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ClassSession> {
			return localVarFp
				.classSessionsCreate(classSession, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp
				.classSessionsDestroy(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ClassSessionDetail>> {
			return localVarFp.classSessionsList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {PatchedClassSessionDetail} [patchedClassSessionDetail]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsPartialUpdate(
			id: string,
			patchedClassSessionDetail?: PatchedClassSessionDetail,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ClassSessionDetail> {
			return localVarFp
				.classSessionsPartialUpdate(id, patchedClassSessionDetail, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ClassSessionDetail> {
			return localVarFp
				.classSessionsRetrieve(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class session.
		 * @param {ClassSession} classSession
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classSessionsUpdate(
			id: string,
			classSession: ClassSession,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ClassSession> {
			return localVarFp
				.classSessionsUpdate(id, classSession, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * ClassSessionsApi - object-oriented interface
 *
 * @class ClassSessionsApi
 * @extends {BaseAPI}
 * @export
 */
export class ClassSessionsApi extends BaseAPI {
	/**
	 * @memberof ClassSessionsApi
	 * @param {ClassSession} classSession
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classSessionsCreate(classSession: ClassSession, options?: RawAxiosRequestConfig) {
		return ClassSessionsApiFp(this.configuration)
			.classSessionsCreate(classSession, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassSessionsApi
	 * @param {string} id A UUID string identifying this class session.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classSessionsDestroy(id: string, options?: RawAxiosRequestConfig) {
		return ClassSessionsApiFp(this.configuration)
			.classSessionsDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassSessionsApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classSessionsList(options?: RawAxiosRequestConfig) {
		return ClassSessionsApiFp(this.configuration)
			.classSessionsList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassSessionsApi
	 * @param {string} id A UUID string identifying this class session.
	 * @param {PatchedClassSessionDetail} [patchedClassSessionDetail]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classSessionsPartialUpdate(
		id: string,
		patchedClassSessionDetail?: PatchedClassSessionDetail,
		options?: RawAxiosRequestConfig,
	) {
		return ClassSessionsApiFp(this.configuration)
			.classSessionsPartialUpdate(id, patchedClassSessionDetail, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassSessionsApi
	 * @param {string} id A UUID string identifying this class session.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classSessionsRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return ClassSessionsApiFp(this.configuration)
			.classSessionsRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassSessionsApi
	 * @param {string} id A UUID string identifying this class session.
	 * @param {ClassSession} classSession
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classSessionsUpdate(
		id: string,
		classSession: ClassSession,
		options?: RawAxiosRequestConfig,
	) {
		return ClassSessionsApiFp(this.configuration)
			.classSessionsUpdate(id, classSession, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * ClassStudentsApi - axios parameter creator
 *
 * @export
 */
export const ClassStudentsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {ClassStudent} classStudent
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsCreate: async (
			classStudent: ClassStudent,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'classStudent' is not null or undefined
			assertParamExists('classStudentsCreate', 'classStudent', classStudent)
			const localVarPath = `/class_students/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				classStudent,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsDestroy: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classStudentsDestroy', 'id', id)
			const localVarPath = `/class_students/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/class_students/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {PatchedClassStudent} [patchedClassStudent]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsPartialUpdate: async (
			id: string,
			patchedClassStudent?: PatchedClassStudent,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classStudentsPartialUpdate', 'id', id)
			const localVarPath = `/class_students/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedClassStudent,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classStudentsRetrieve', 'id', id)
			const localVarPath = `/class_students/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {ClassStudent} classStudent
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsUpdate: async (
			id: string,
			classStudent: ClassStudent,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classStudentsUpdate', 'id', id)
			// verify required parameter 'classStudent' is not null or undefined
			assertParamExists('classStudentsUpdate', 'classStudent', classStudent)
			const localVarPath = `/class_students/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				classStudent,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ClassStudentsApi - functional programming interface
 *
 * @export
 */
export const ClassStudentsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ClassStudentsApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {ClassStudent} classStudent
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classStudentsCreate(
			classStudent: ClassStudent,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsCreate(
				classStudent,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassStudentsApi.classStudentsCreate']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classStudentsDestroy(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsDestroy(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassStudentsApi.classStudentsDestroy']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classStudentsList(
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassStudent>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassStudentsApi.classStudentsList']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {PatchedClassStudent} [patchedClassStudent]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classStudentsPartialUpdate(
			id: string,
			patchedClassStudent?: PatchedClassStudent,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsPartialUpdate(
				id,
				patchedClassStudent,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassStudentsApi.classStudentsPartialUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classStudentsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsRetrieve(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassStudentsApi.classStudentsRetrieve']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {ClassStudent} classStudent
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classStudentsUpdate(
			id: string,
			classStudent: ClassStudent,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassStudent>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classStudentsUpdate(
				id,
				classStudent,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassStudentsApi.classStudentsUpdate']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * ClassStudentsApi - factory interface
 *
 * @export
 */
export const ClassStudentsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = ClassStudentsApiFp(configuration)
	return {
		/**
		 * @param {ClassStudent} classStudent
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsCreate(
			classStudent: ClassStudent,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ClassStudent> {
			return localVarFp
				.classStudentsCreate(classStudent, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp
				.classStudentsDestroy(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ClassStudent>> {
			return localVarFp.classStudentsList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {PatchedClassStudent} [patchedClassStudent]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsPartialUpdate(
			id: string,
			patchedClassStudent?: PatchedClassStudent,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ClassStudent> {
			return localVarFp
				.classStudentsPartialUpdate(id, patchedClassStudent, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ClassStudent> {
			return localVarFp
				.classStudentsRetrieve(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class student.
		 * @param {ClassStudent} classStudent
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classStudentsUpdate(
			id: string,
			classStudent: ClassStudent,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ClassStudent> {
			return localVarFp
				.classStudentsUpdate(id, classStudent, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * ClassStudentsApi - object-oriented interface
 *
 * @class ClassStudentsApi
 * @extends {BaseAPI}
 * @export
 */
export class ClassStudentsApi extends BaseAPI {
	/**
	 * @memberof ClassStudentsApi
	 * @param {ClassStudent} classStudent
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classStudentsCreate(classStudent: ClassStudent, options?: RawAxiosRequestConfig) {
		return ClassStudentsApiFp(this.configuration)
			.classStudentsCreate(classStudent, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassStudentsApi
	 * @param {string} id A UUID string identifying this class student.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classStudentsDestroy(id: string, options?: RawAxiosRequestConfig) {
		return ClassStudentsApiFp(this.configuration)
			.classStudentsDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassStudentsApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classStudentsList(options?: RawAxiosRequestConfig) {
		return ClassStudentsApiFp(this.configuration)
			.classStudentsList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassStudentsApi
	 * @param {string} id A UUID string identifying this class student.
	 * @param {PatchedClassStudent} [patchedClassStudent]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classStudentsPartialUpdate(
		id: string,
		patchedClassStudent?: PatchedClassStudent,
		options?: RawAxiosRequestConfig,
	) {
		return ClassStudentsApiFp(this.configuration)
			.classStudentsPartialUpdate(id, patchedClassStudent, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassStudentsApi
	 * @param {string} id A UUID string identifying this class student.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classStudentsRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return ClassStudentsApiFp(this.configuration)
			.classStudentsRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassStudentsApi
	 * @param {string} id A UUID string identifying this class student.
	 * @param {ClassStudent} classStudent
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classStudentsUpdate(
		id: string,
		classStudent: ClassStudent,
		options?: RawAxiosRequestConfig,
	) {
		return ClassStudentsApiFp(this.configuration)
			.classStudentsUpdate(id, classStudent, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * ClassesApi - axios parameter creator
 *
 * @export
 */
export const ClassesApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesBulkDeleteCreate: async (
			_class: Class,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter '_class' is not null or undefined
			assertParamExists('classesBulkDeleteCreate', '_class', _class)
			const localVarPath = `/classes/bulk_delete/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				_class,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesCreate: async (
			_class: Class,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter '_class' is not null or undefined
			assertParamExists('classesCreate', '_class', _class)
			const localVarPath = `/classes/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				_class,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesDestroy: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classesDestroy', 'id', id)
			const localVarPath = `/classes/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/classes/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {PatchedClass} [patchedClass]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesPartialUpdate: async (
			id: string,
			patchedClass?: PatchedClass,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classesPartialUpdate', 'id', id)
			const localVarPath = `/classes/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedClass,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classesRetrieve', 'id', id)
			const localVarPath = `/classes/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesUpdate: async (
			id: string,
			_class: Class,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classesUpdate', 'id', id)
			// verify required parameter '_class' is not null or undefined
			assertParamExists('classesUpdate', '_class', _class)
			const localVarPath = `/classes/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				_class,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesUpdateStudentsUpdate: async (
			id: string,
			_class: Class,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('classesUpdateStudentsUpdate', 'id', id)
			// verify required parameter '_class' is not null or undefined
			assertParamExists('classesUpdateStudentsUpdate', '_class', _class)
			const localVarPath = `/classes/{id}/update_students/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				_class,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ClassesApi - functional programming interface
 *
 * @export
 */
export const ClassesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ClassesApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classesBulkDeleteCreate(
			_class: Class,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classesBulkDeleteCreate(
				_class,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassesApi.classesBulkDeleteCreate']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classesCreate(
			_class: Class,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classesCreate(_class, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassesApi.classesCreate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classesDestroy(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classesDestroy(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassesApi.classesDestroy']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classesList(
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Class>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classesList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassesApi.classesList']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {PatchedClass} [patchedClass]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classesPartialUpdate(
			id: string,
			patchedClass?: PatchedClass,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classesPartialUpdate(
				id,
				patchedClass,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassesApi.classesPartialUpdate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classesRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classesRetrieve(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassesApi.classesRetrieve']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classesUpdate(
			id: string,
			_class: Class,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classesUpdate(id, _class, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassesApi.classesUpdate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async classesUpdateStudentsUpdate(
			id: string,
			_class: Class,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Class>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.classesUpdateStudentsUpdate(
				id,
				_class,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ClassesApi.classesUpdateStudentsUpdate']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * ClassesApi - factory interface
 *
 * @export
 */
export const ClassesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = ClassesApiFp(configuration)
	return {
		/**
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesBulkDeleteCreate(_class: Class, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
			return localVarFp
				.classesBulkDeleteCreate(_class, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesCreate(_class: Class, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
			return localVarFp.classesCreate(_class, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp.classesDestroy(id, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Class>> {
			return localVarFp.classesList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {PatchedClass} [patchedClass]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesPartialUpdate(
			id: string,
			patchedClass?: PatchedClass,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Class> {
			return localVarFp
				.classesPartialUpdate(id, patchedClass, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
			return localVarFp.classesRetrieve(id, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig): AxiosPromise<Class> {
			return localVarFp
				.classesUpdate(id, _class, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this class.
		 * @param {Class} _class
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		classesUpdateStudentsUpdate(
			id: string,
			_class: Class,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Class> {
			return localVarFp
				.classesUpdateStudentsUpdate(id, _class, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * ClassesApi - object-oriented interface
 *
 * @class ClassesApi
 * @extends {BaseAPI}
 * @export
 */
export class ClassesApi extends BaseAPI {
	/**
	 * @memberof ClassesApi
	 * @param {Class} _class
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classesBulkDeleteCreate(_class: Class, options?: RawAxiosRequestConfig) {
		return ClassesApiFp(this.configuration)
			.classesBulkDeleteCreate(_class, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassesApi
	 * @param {Class} _class
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classesCreate(_class: Class, options?: RawAxiosRequestConfig) {
		return ClassesApiFp(this.configuration)
			.classesCreate(_class, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassesApi
	 * @param {string} id A UUID string identifying this class.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classesDestroy(id: string, options?: RawAxiosRequestConfig) {
		return ClassesApiFp(this.configuration)
			.classesDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassesApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classesList(options?: RawAxiosRequestConfig) {
		return ClassesApiFp(this.configuration)
			.classesList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassesApi
	 * @param {string} id A UUID string identifying this class.
	 * @param {PatchedClass} [patchedClass]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classesPartialUpdate(
		id: string,
		patchedClass?: PatchedClass,
		options?: RawAxiosRequestConfig,
	) {
		return ClassesApiFp(this.configuration)
			.classesPartialUpdate(id, patchedClass, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassesApi
	 * @param {string} id A UUID string identifying this class.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classesRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return ClassesApiFp(this.configuration)
			.classesRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassesApi
	 * @param {string} id A UUID string identifying this class.
	 * @param {Class} _class
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classesUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig) {
		return ClassesApiFp(this.configuration)
			.classesUpdate(id, _class, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ClassesApi
	 * @param {string} id A UUID string identifying this class.
	 * @param {Class} _class
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public classesUpdateStudentsUpdate(id: string, _class: Class, options?: RawAxiosRequestConfig) {
		return ClassesApiFp(this.configuration)
			.classesUpdateStudentsUpdate(id, _class, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * CourseEnrollmentsApi - axios parameter creator
 *
 * @export
 */
export const CourseEnrollmentsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {CourseEnrollment} courseEnrollment
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsBulkDeleteCreate: async (
			courseEnrollment: CourseEnrollment,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'courseEnrollment' is not null or undefined
			assertParamExists('courseEnrollmentsBulkDeleteCreate', 'courseEnrollment', courseEnrollment)
			const localVarPath = `/course_enrollments/bulk_delete/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				courseEnrollment,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {CourseEnrollment} courseEnrollment
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsCreate: async (
			courseEnrollment: CourseEnrollment,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'courseEnrollment' is not null or undefined
			assertParamExists('courseEnrollmentsCreate', 'courseEnrollment', courseEnrollment)
			const localVarPath = `/course_enrollments/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				courseEnrollment,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsDestroy: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('courseEnrollmentsDestroy', 'id', id)
			const localVarPath = `/course_enrollments/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/course_enrollments/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {PatchedCourseEnrollment} [patchedCourseEnrollment]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsPartialUpdate: async (
			id: string,
			patchedCourseEnrollment?: PatchedCourseEnrollment,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('courseEnrollmentsPartialUpdate', 'id', id)
			const localVarPath = `/course_enrollments/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedCourseEnrollment,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('courseEnrollmentsRetrieve', 'id', id)
			const localVarPath = `/course_enrollments/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {CourseEnrollment} courseEnrollment
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsUpdate: async (
			id: string,
			courseEnrollment: CourseEnrollment,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('courseEnrollmentsUpdate', 'id', id)
			// verify required parameter 'courseEnrollment' is not null or undefined
			assertParamExists('courseEnrollmentsUpdate', 'courseEnrollment', courseEnrollment)
			const localVarPath = `/course_enrollments/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				courseEnrollment,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * CourseEnrollmentsApi - functional programming interface
 *
 * @export
 */
export const CourseEnrollmentsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = CourseEnrollmentsApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {CourseEnrollment} courseEnrollment
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async courseEnrollmentsBulkDeleteCreate(
			courseEnrollment: CourseEnrollment,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEnrollment>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsBulkDeleteCreate(
				courseEnrollment,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CourseEnrollmentsApi.courseEnrollmentsBulkDeleteCreate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {CourseEnrollment} courseEnrollment
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async courseEnrollmentsCreate(
			courseEnrollment: CourseEnrollment,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEnrollment>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsCreate(
				courseEnrollment,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CourseEnrollmentsApi.courseEnrollmentsCreate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async courseEnrollmentsDestroy(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsDestroy(
				id,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CourseEnrollmentsApi.courseEnrollmentsDestroy']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async courseEnrollmentsList(
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CourseEnrollment>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CourseEnrollmentsApi.courseEnrollmentsList']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {PatchedCourseEnrollment} [patchedCourseEnrollment]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async courseEnrollmentsPartialUpdate(
			id: string,
			patchedCourseEnrollment?: PatchedCourseEnrollment,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEnrollment>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsPartialUpdate(
				id,
				patchedCourseEnrollment,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CourseEnrollmentsApi.courseEnrollmentsPartialUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async courseEnrollmentsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEnrollment>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsRetrieve(
				id,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CourseEnrollmentsApi.courseEnrollmentsRetrieve']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {CourseEnrollment} courseEnrollment
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async courseEnrollmentsUpdate(
			id: string,
			courseEnrollment: CourseEnrollment,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseEnrollment>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollmentsUpdate(
				id,
				courseEnrollment,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CourseEnrollmentsApi.courseEnrollmentsUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * CourseEnrollmentsApi - factory interface
 *
 * @export
 */
export const CourseEnrollmentsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = CourseEnrollmentsApiFp(configuration)
	return {
		/**
		 * @param {CourseEnrollment} courseEnrollment
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsBulkDeleteCreate(
			courseEnrollment: CourseEnrollment,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CourseEnrollment> {
			return localVarFp
				.courseEnrollmentsBulkDeleteCreate(courseEnrollment, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {CourseEnrollment} courseEnrollment
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsCreate(
			courseEnrollment: CourseEnrollment,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CourseEnrollment> {
			return localVarFp
				.courseEnrollmentsCreate(courseEnrollment, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp
				.courseEnrollmentsDestroy(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CourseEnrollment>> {
			return localVarFp.courseEnrollmentsList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {PatchedCourseEnrollment} [patchedCourseEnrollment]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsPartialUpdate(
			id: string,
			patchedCourseEnrollment?: PatchedCourseEnrollment,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CourseEnrollment> {
			return localVarFp
				.courseEnrollmentsPartialUpdate(id, patchedCourseEnrollment, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CourseEnrollment> {
			return localVarFp
				.courseEnrollmentsRetrieve(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this course enrollment.
		 * @param {CourseEnrollment} courseEnrollment
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseEnrollmentsUpdate(
			id: string,
			courseEnrollment: CourseEnrollment,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CourseEnrollment> {
			return localVarFp
				.courseEnrollmentsUpdate(id, courseEnrollment, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * CourseEnrollmentsApi - object-oriented interface
 *
 * @class CourseEnrollmentsApi
 * @extends {BaseAPI}
 * @export
 */
export class CourseEnrollmentsApi extends BaseAPI {
	/**
	 * @memberof CourseEnrollmentsApi
	 * @param {CourseEnrollment} courseEnrollment
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public courseEnrollmentsBulkDeleteCreate(
		courseEnrollment: CourseEnrollment,
		options?: RawAxiosRequestConfig,
	) {
		return CourseEnrollmentsApiFp(this.configuration)
			.courseEnrollmentsBulkDeleteCreate(courseEnrollment, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CourseEnrollmentsApi
	 * @param {CourseEnrollment} courseEnrollment
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public courseEnrollmentsCreate(
		courseEnrollment: CourseEnrollment,
		options?: RawAxiosRequestConfig,
	) {
		return CourseEnrollmentsApiFp(this.configuration)
			.courseEnrollmentsCreate(courseEnrollment, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CourseEnrollmentsApi
	 * @param {string} id A UUID string identifying this course enrollment.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public courseEnrollmentsDestroy(id: string, options?: RawAxiosRequestConfig) {
		return CourseEnrollmentsApiFp(this.configuration)
			.courseEnrollmentsDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CourseEnrollmentsApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public courseEnrollmentsList(options?: RawAxiosRequestConfig) {
		return CourseEnrollmentsApiFp(this.configuration)
			.courseEnrollmentsList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CourseEnrollmentsApi
	 * @param {string} id A UUID string identifying this course enrollment.
	 * @param {PatchedCourseEnrollment} [patchedCourseEnrollment]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public courseEnrollmentsPartialUpdate(
		id: string,
		patchedCourseEnrollment?: PatchedCourseEnrollment,
		options?: RawAxiosRequestConfig,
	) {
		return CourseEnrollmentsApiFp(this.configuration)
			.courseEnrollmentsPartialUpdate(id, patchedCourseEnrollment, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CourseEnrollmentsApi
	 * @param {string} id A UUID string identifying this course enrollment.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public courseEnrollmentsRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return CourseEnrollmentsApiFp(this.configuration)
			.courseEnrollmentsRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CourseEnrollmentsApi
	 * @param {string} id A UUID string identifying this course enrollment.
	 * @param {CourseEnrollment} courseEnrollment
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public courseEnrollmentsUpdate(
		id: string,
		courseEnrollment: CourseEnrollment,
		options?: RawAxiosRequestConfig,
	) {
		return CourseEnrollmentsApiFp(this.configuration)
			.courseEnrollmentsUpdate(id, courseEnrollment, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * CoursesApi - axios parameter creator
 *
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Course} course
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesBulkDeleteCreate: async (
			course: Course,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'course' is not null or undefined
			assertParamExists('coursesBulkDeleteCreate', 'course', course)
			const localVarPath = `/courses/bulk_delete/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				course,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {Course} course
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesCreate: async (
			course: Course,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'course' is not null or undefined
			assertParamExists('coursesCreate', 'course', course)
			const localVarPath = `/courses/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				course,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesDestroy: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('coursesDestroy', 'id', id)
			const localVarPath = `/courses/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/courses/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {PatchedCourse} [patchedCourse]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesPartialUpdate: async (
			id: string,
			patchedCourse?: PatchedCourse,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('coursesPartialUpdate', 'id', id)
			const localVarPath = `/courses/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedCourse,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('coursesRetrieve', 'id', id)
			const localVarPath = `/courses/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {Course} course
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesUpdate: async (
			id: string,
			course: Course,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('coursesUpdate', 'id', id)
			// verify required parameter 'course' is not null or undefined
			assertParamExists('coursesUpdate', 'course', course)
			const localVarPath = `/courses/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				course,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * CoursesApi - functional programming interface
 *
 * @export
 */
export const CoursesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {Course} course
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coursesBulkDeleteCreate(
			course: Course,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.coursesBulkDeleteCreate(
				course,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CoursesApi.coursesBulkDeleteCreate']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {Course} course
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coursesCreate(
			course: Course,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.coursesCreate(course, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CoursesApi.coursesCreate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coursesDestroy(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.coursesDestroy(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CoursesApi.coursesDestroy']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coursesList(
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Course>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.coursesList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CoursesApi.coursesList']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {PatchedCourse} [patchedCourse]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coursesPartialUpdate(
			id: string,
			patchedCourse?: PatchedCourse,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.coursesPartialUpdate(
				id,
				patchedCourse,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CoursesApi.coursesPartialUpdate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coursesRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.coursesRetrieve(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CoursesApi.coursesRetrieve']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {Course} course
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coursesUpdate(
			id: string,
			course: Course,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Course>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.coursesUpdate(id, course, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['CoursesApi.coursesUpdate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * CoursesApi - factory interface
 *
 * @export
 */
export const CoursesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = CoursesApiFp(configuration)
	return {
		/**
		 * @param {Course} course
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesBulkDeleteCreate(course: Course, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
			return localVarFp
				.coursesBulkDeleteCreate(course, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {Course} course
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesCreate(course: Course, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
			return localVarFp.coursesCreate(course, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp.coursesDestroy(id, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Course>> {
			return localVarFp.coursesList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {PatchedCourse} [patchedCourse]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesPartialUpdate(
			id: string,
			patchedCourse?: PatchedCourse,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Course> {
			return localVarFp
				.coursesPartialUpdate(id, patchedCourse, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Course> {
			return localVarFp.coursesRetrieve(id, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this course.
		 * @param {Course} course
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coursesUpdate(
			id: string,
			course: Course,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Course> {
			return localVarFp
				.coursesUpdate(id, course, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * CoursesApi - object-oriented interface
 *
 * @class CoursesApi
 * @extends {BaseAPI}
 * @export
 */
export class CoursesApi extends BaseAPI {
	/**
	 * @memberof CoursesApi
	 * @param {Course} course
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesBulkDeleteCreate(course: Course, options?: RawAxiosRequestConfig) {
		return CoursesApiFp(this.configuration)
			.coursesBulkDeleteCreate(course, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CoursesApi
	 * @param {Course} course
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesCreate(course: Course, options?: RawAxiosRequestConfig) {
		return CoursesApiFp(this.configuration)
			.coursesCreate(course, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CoursesApi
	 * @param {string} id A UUID string identifying this course.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesDestroy(id: string, options?: RawAxiosRequestConfig) {
		return CoursesApiFp(this.configuration)
			.coursesDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CoursesApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesList(options?: RawAxiosRequestConfig) {
		return CoursesApiFp(this.configuration)
			.coursesList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CoursesApi
	 * @param {string} id A UUID string identifying this course.
	 * @param {PatchedCourse} [patchedCourse]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesPartialUpdate(
		id: string,
		patchedCourse?: PatchedCourse,
		options?: RawAxiosRequestConfig,
	) {
		return CoursesApiFp(this.configuration)
			.coursesPartialUpdate(id, patchedCourse, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CoursesApi
	 * @param {string} id A UUID string identifying this course.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return CoursesApiFp(this.configuration)
			.coursesRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof CoursesApi
	 * @param {string} id A UUID string identifying this course.
	 * @param {Course} course
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public coursesUpdate(id: string, course: Course, options?: RawAxiosRequestConfig) {
		return CoursesApiFp(this.configuration)
			.coursesUpdate(id, course, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * GradesApi - axios parameter creator
 *
 * @export
 */
export const GradesApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Grade} grade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesCreate: async (
			grade: Grade,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'grade' is not null or undefined
			assertParamExists('gradesCreate', 'grade', grade)
			const localVarPath = `/grades/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				grade,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesDestroy: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('gradesDestroy', 'id', id)
			const localVarPath = `/grades/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/grades/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {PatchedGrade} [patchedGrade]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesPartialUpdate: async (
			id: string,
			patchedGrade?: PatchedGrade,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('gradesPartialUpdate', 'id', id)
			const localVarPath = `/grades/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedGrade,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('gradesRetrieve', 'id', id)
			const localVarPath = `/grades/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {Grade} grade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesUpdate: async (
			id: string,
			grade: Grade,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('gradesUpdate', 'id', id)
			// verify required parameter 'grade' is not null or undefined
			assertParamExists('gradesUpdate', 'grade', grade)
			const localVarPath = `/grades/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				grade,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * GradesApi - functional programming interface
 *
 * @export
 */
export const GradesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = GradesApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {Grade} grade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async gradesCreate(
			grade: Grade,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grade>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.gradesCreate(grade, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['GradesApi.gradesCreate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async gradesDestroy(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.gradesDestroy(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['GradesApi.gradesDestroy']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async gradesList(
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Grade>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.gradesList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['GradesApi.gradesList']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {PatchedGrade} [patchedGrade]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async gradesPartialUpdate(
			id: string,
			patchedGrade?: PatchedGrade,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grade>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.gradesPartialUpdate(
				id,
				patchedGrade,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['GradesApi.gradesPartialUpdate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async gradesRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grade>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.gradesRetrieve(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['GradesApi.gradesRetrieve']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {Grade} grade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async gradesUpdate(
			id: string,
			grade: Grade,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grade>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.gradesUpdate(id, grade, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['GradesApi.gradesUpdate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * GradesApi - factory interface
 *
 * @export
 */
export const GradesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = GradesApiFp(configuration)
	return {
		/**
		 * @param {Grade} grade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesCreate(grade: Grade, options?: RawAxiosRequestConfig): AxiosPromise<Grade> {
			return localVarFp.gradesCreate(grade, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp.gradesDestroy(id, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Grade>> {
			return localVarFp.gradesList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {PatchedGrade} [patchedGrade]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesPartialUpdate(
			id: string,
			patchedGrade?: PatchedGrade,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Grade> {
			return localVarFp
				.gradesPartialUpdate(id, patchedGrade, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Grade> {
			return localVarFp.gradesRetrieve(id, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this grade.
		 * @param {Grade} grade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		gradesUpdate(id: string, grade: Grade, options?: RawAxiosRequestConfig): AxiosPromise<Grade> {
			return localVarFp.gradesUpdate(id, grade, options).then((request) => request(axios, basePath))
		},
	}
}

/**
 * GradesApi - object-oriented interface
 *
 * @class GradesApi
 * @extends {BaseAPI}
 * @export
 */
export class GradesApi extends BaseAPI {
	/**
	 * @memberof GradesApi
	 * @param {Grade} grade
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public gradesCreate(grade: Grade, options?: RawAxiosRequestConfig) {
		return GradesApiFp(this.configuration)
			.gradesCreate(grade, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof GradesApi
	 * @param {string} id A UUID string identifying this grade.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public gradesDestroy(id: string, options?: RawAxiosRequestConfig) {
		return GradesApiFp(this.configuration)
			.gradesDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof GradesApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public gradesList(options?: RawAxiosRequestConfig) {
		return GradesApiFp(this.configuration)
			.gradesList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof GradesApi
	 * @param {string} id A UUID string identifying this grade.
	 * @param {PatchedGrade} [patchedGrade]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public gradesPartialUpdate(
		id: string,
		patchedGrade?: PatchedGrade,
		options?: RawAxiosRequestConfig,
	) {
		return GradesApiFp(this.configuration)
			.gradesPartialUpdate(id, patchedGrade, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof GradesApi
	 * @param {string} id A UUID string identifying this grade.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public gradesRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return GradesApiFp(this.configuration)
			.gradesRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof GradesApi
	 * @param {string} id A UUID string identifying this grade.
	 * @param {Grade} grade
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public gradesUpdate(id: string, grade: Grade, options?: RawAxiosRequestConfig) {
		return GradesApiFp(this.configuration)
			.gradesUpdate(id, grade, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * ImportApi - axios parameter creator
 *
 * @export
 */
export const ImportApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * Creates a new class import
		 *
		 * @param {Import} _import
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importClassesCreate: async (
			_import: Import,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter '_import' is not null or undefined
			assertParamExists('importClassesCreate', '_import', _import)
			const localVarPath = `/import/classes/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				_import,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Retrieves class import information
		 *
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importClassesRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/import/classes/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Creates a new course import
		 *
		 * @param {Import} _import
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importCoursesCreate: async (
			_import: Import,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter '_import' is not null or undefined
			assertParamExists('importCoursesCreate', '_import', _import)
			const localVarPath = `/import/courses/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				_import,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Retrieves course import information
		 *
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importCoursesRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/import/courses/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} importId
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importRetrieve: async (
			importId: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'importId' is not null or undefined
			assertParamExists('importRetrieve', 'importId', importId)
			const localVarPath = `/import/{import_id}/`.replace(
				`{${'import_id'}}`,
				encodeURIComponent(String(importId)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Creates a new user import
		 *
		 * @param {Import} _import
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUsersCreate: async (
			_import: Import,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter '_import' is not null or undefined
			assertParamExists('importUsersCreate', '_import', _import)
			const localVarPath = `/import/users/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				_import,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Retrieves user import information
		 *
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUsersRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/import/users/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ImportApi - functional programming interface
 *
 * @export
 */
export const ImportApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ImportApiAxiosParamCreator(configuration)
	return {
		/**
		 * Creates a new class import
		 *
		 * @param {Import} _import
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importClassesCreate(
			_import: Import,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateImportResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.importClassesCreate(
				_import,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ImportApi.importClassesCreate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Retrieves class import information
		 *
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importClassesRetrieve(
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.importClassesRetrieve(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ImportApi.importClassesRetrieve']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Creates a new course import
		 *
		 * @param {Import} _import
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importCoursesCreate(
			_import: Import,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateImportResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.importCoursesCreate(
				_import,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ImportApi.importCoursesCreate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Retrieves course import information
		 *
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importCoursesRetrieve(
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.importCoursesRetrieve(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ImportApi.importCoursesRetrieve']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} importId
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importRetrieve(
			importId: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.importRetrieve(importId, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ImportApi.importRetrieve']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Creates a new user import
		 *
		 * @param {Import} _import
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importUsersCreate(
			_import: Import,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateImportResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.importUsersCreate(_import, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ImportApi.importUsersCreate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Retrieves user import information
		 *
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importUsersRetrieve(
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatus>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.importUsersRetrieve(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ImportApi.importUsersRetrieve']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * ImportApi - factory interface
 *
 * @export
 */
export const ImportApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = ImportApiFp(configuration)
	return {
		/**
		 * Creates a new class import
		 *
		 * @param {Import} _import
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importClassesCreate(
			_import: Import,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CreateImportResponse> {
			return localVarFp
				.importClassesCreate(_import, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Retrieves class import information
		 *
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importClassesRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
			return localVarFp.importClassesRetrieve(options).then((request) => request(axios, basePath))
		},
		/**
		 * Creates a new course import
		 *
		 * @param {Import} _import
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importCoursesCreate(
			_import: Import,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CreateImportResponse> {
			return localVarFp
				.importCoursesCreate(_import, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Retrieves course import information
		 *
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importCoursesRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
			return localVarFp.importCoursesRetrieve(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} importId
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importRetrieve(importId: string, options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
			return localVarFp
				.importRetrieve(importId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Creates a new user import
		 *
		 * @param {Import} _import
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUsersCreate(
			_import: Import,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CreateImportResponse> {
			return localVarFp
				.importUsersCreate(_import, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Retrieves user import information
		 *
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUsersRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<ImportStatus> {
			return localVarFp.importUsersRetrieve(options).then((request) => request(axios, basePath))
		},
	}
}

/**
 * ImportApi - object-oriented interface
 *
 * @class ImportApi
 * @extends {BaseAPI}
 * @export
 */
export class ImportApi extends BaseAPI {
	/**
	 * Creates a new class import
	 *
	 * @memberof ImportApi
	 * @param {Import} _import
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public importClassesCreate(_import: Import, options?: RawAxiosRequestConfig) {
		return ImportApiFp(this.configuration)
			.importClassesCreate(_import, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Retrieves class import information
	 *
	 * @memberof ImportApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public importClassesRetrieve(options?: RawAxiosRequestConfig) {
		return ImportApiFp(this.configuration)
			.importClassesRetrieve(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Creates a new course import
	 *
	 * @memberof ImportApi
	 * @param {Import} _import
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public importCoursesCreate(_import: Import, options?: RawAxiosRequestConfig) {
		return ImportApiFp(this.configuration)
			.importCoursesCreate(_import, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Retrieves course import information
	 *
	 * @memberof ImportApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public importCoursesRetrieve(options?: RawAxiosRequestConfig) {
		return ImportApiFp(this.configuration)
			.importCoursesRetrieve(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof ImportApi
	 * @param {string} importId
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public importRetrieve(importId: string, options?: RawAxiosRequestConfig) {
		return ImportApiFp(this.configuration)
			.importRetrieve(importId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Creates a new user import
	 *
	 * @memberof ImportApi
	 * @param {Import} _import
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public importUsersCreate(_import: Import, options?: RawAxiosRequestConfig) {
		return ImportApiFp(this.configuration)
			.importUsersCreate(_import, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Retrieves user import information
	 *
	 * @memberof ImportApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public importUsersRetrieve(options?: RawAxiosRequestConfig) {
		return ImportApiFp(this.configuration)
			.importUsersRetrieve(options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SchemaApi - axios parameter creator
 *
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * OpenApi3 schema for this API. Format can be selected via content
		 * negotiation. - YAML: application/vnd.oai.openapi - JSON:
		 * application/vnd.oai.openapi+json
		 *
		 * @param {SchemaRetrieveFormatEnum} [format]
		 * @param {SchemaRetrieveLangEnum} [lang]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		schemaRetrieve: async (
			format?: SchemaRetrieveFormatEnum,
			lang?: SchemaRetrieveLangEnum,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/schema/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			if (format !== undefined) {
				localVarQueryParameter['format'] = format
			}

			if (lang !== undefined) {
				localVarQueryParameter['lang'] = lang
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SchemaApi - functional programming interface
 *
 * @export
 */
export const SchemaApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
	return {
		/**
		 * OpenApi3 schema for this API. Format can be selected via content
		 * negotiation. - YAML: application/vnd.oai.openapi - JSON:
		 * application/vnd.oai.openapi+json
		 *
		 * @param {SchemaRetrieveFormatEnum} [format]
		 * @param {SchemaRetrieveLangEnum} [lang]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async schemaRetrieve(
			format?: SchemaRetrieveFormatEnum,
			lang?: SchemaRetrieveLangEnum,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any }>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(
				format,
				lang,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SchemaApi.schemaRetrieve']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SchemaApi - factory interface
 *
 * @export
 */
export const SchemaApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = SchemaApiFp(configuration)
	return {
		/**
		 * OpenApi3 schema for this API. Format can be selected via content
		 * negotiation. - YAML: application/vnd.oai.openapi - JSON:
		 * application/vnd.oai.openapi+json
		 *
		 * @param {SchemaRetrieveFormatEnum} [format]
		 * @param {SchemaRetrieveLangEnum} [lang]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		schemaRetrieve(
			format?: SchemaRetrieveFormatEnum,
			lang?: SchemaRetrieveLangEnum,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<{ [key: string]: any }> {
			return localVarFp
				.schemaRetrieve(format, lang, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SchemaApi - object-oriented interface
 *
 * @class SchemaApi
 * @extends {BaseAPI}
 * @export
 */
export class SchemaApi extends BaseAPI {
	/**
	 * OpenApi3 schema for this API. Format can be selected via content
	 * negotiation. - YAML: application/vnd.oai.openapi - JSON:
	 * application/vnd.oai.openapi+json
	 *
	 * @memberof SchemaApi
	 * @param {SchemaRetrieveFormatEnum} [format]
	 * @param {SchemaRetrieveLangEnum} [lang]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public schemaRetrieve(
		format?: SchemaRetrieveFormatEnum,
		lang?: SchemaRetrieveLangEnum,
		options?: RawAxiosRequestConfig,
	) {
		return SchemaApiFp(this.configuration)
			.schemaRetrieve(format, lang, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/** @export */
export const SchemaRetrieveFormatEnum = {
	Json: 'json',
	Yaml: 'yaml',
} as const
export type SchemaRetrieveFormatEnum =
	(typeof SchemaRetrieveFormatEnum)[keyof typeof SchemaRetrieveFormatEnum]
/** @export */
export const SchemaRetrieveLangEnum = {
	Af: 'af',
	Ar: 'ar',
	ArDz: 'ar-dz',
	Ast: 'ast',
	Az: 'az',
	Be: 'be',
	Bg: 'bg',
	Bn: 'bn',
	Br: 'br',
	Bs: 'bs',
	Ca: 'ca',
	Ckb: 'ckb',
	Cs: 'cs',
	Cy: 'cy',
	Da: 'da',
	De: 'de',
	Dsb: 'dsb',
	El: 'el',
	En: 'en',
	EnAu: 'en-au',
	EnGb: 'en-gb',
	Eo: 'eo',
	Es: 'es',
	EsAr: 'es-ar',
	EsCo: 'es-co',
	EsMx: 'es-mx',
	EsNi: 'es-ni',
	EsVe: 'es-ve',
	Et: 'et',
	Eu: 'eu',
	Fa: 'fa',
	Fi: 'fi',
	Fr: 'fr',
	Fy: 'fy',
	Ga: 'ga',
	Gd: 'gd',
	Gl: 'gl',
	He: 'he',
	Hi: 'hi',
	Hr: 'hr',
	Hsb: 'hsb',
	Hu: 'hu',
	Hy: 'hy',
	Ia: 'ia',
	Id: 'id',
	Ig: 'ig',
	Io: 'io',
	Is: 'is',
	It: 'it',
	Ja: 'ja',
	Ka: 'ka',
	Kab: 'kab',
	Kk: 'kk',
	Km: 'km',
	Kn: 'kn',
	Ko: 'ko',
	Ky: 'ky',
	Lb: 'lb',
	Lt: 'lt',
	Lv: 'lv',
	Mk: 'mk',
	Ml: 'ml',
	Mn: 'mn',
	Mr: 'mr',
	Ms: 'ms',
	My: 'my',
	Nb: 'nb',
	Ne: 'ne',
	Nl: 'nl',
	Nn: 'nn',
	Os: 'os',
	Pa: 'pa',
	Pl: 'pl',
	Pt: 'pt',
	PtBr: 'pt-br',
	Ro: 'ro',
	Ru: 'ru',
	Sk: 'sk',
	Sl: 'sl',
	Sq: 'sq',
	Sr: 'sr',
	SrLatn: 'sr-latn',
	Sv: 'sv',
	Sw: 'sw',
	Ta: 'ta',
	Te: 'te',
	Tg: 'tg',
	Th: 'th',
	Tk: 'tk',
	Tr: 'tr',
	Tt: 'tt',
	Udm: 'udm',
	Ug: 'ug',
	Uk: 'uk',
	Ur: 'ur',
	Uz: 'uz',
	Vi: 'vi',
	ZhHans: 'zh-hans',
	ZhHant: 'zh-hant',
} as const
export type SchemaRetrieveLangEnum =
	(typeof SchemaRetrieveLangEnum)[keyof typeof SchemaRetrieveLangEnum]

/**
 * StudentGradesApi - axios parameter creator
 *
 * @export
 */
export const StudentGradesApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {StudentGrade} studentGrade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesCreate: async (
			studentGrade: StudentGrade,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'studentGrade' is not null or undefined
			assertParamExists('studentGradesCreate', 'studentGrade', studentGrade)
			const localVarPath = `/student_grades/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				studentGrade,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesDestroy: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('studentGradesDestroy', 'id', id)
			const localVarPath = `/student_grades/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/student_grades/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {PatchedStudentGrade} [patchedStudentGrade]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesPartialUpdate: async (
			id: string,
			patchedStudentGrade?: PatchedStudentGrade,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('studentGradesPartialUpdate', 'id', id)
			const localVarPath = `/student_grades/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedStudentGrade,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesRetrieve: async (
			id: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('studentGradesRetrieve', 'id', id)
			const localVarPath = `/student_grades/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {StudentGrade} studentGrade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesUpdate: async (
			id: string,
			studentGrade: StudentGrade,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('studentGradesUpdate', 'id', id)
			// verify required parameter 'studentGrade' is not null or undefined
			assertParamExists('studentGradesUpdate', 'studentGrade', studentGrade)
			const localVarPath = `/student_grades/{id}/`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id)),
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				studentGrade,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * StudentGradesApi - functional programming interface
 *
 * @export
 */
export const StudentGradesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = StudentGradesApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {StudentGrade} studentGrade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async studentGradesCreate(
			studentGrade: StudentGrade,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesCreate(
				studentGrade,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['StudentGradesApi.studentGradesCreate']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async studentGradesDestroy(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesDestroy(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['StudentGradesApi.studentGradesDestroy']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async studentGradesList(
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudentGrade>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['StudentGradesApi.studentGradesList']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {PatchedStudentGrade} [patchedStudentGrade]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async studentGradesPartialUpdate(
			id: string,
			patchedStudentGrade?: PatchedStudentGrade,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesPartialUpdate(
				id,
				patchedStudentGrade,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['StudentGradesApi.studentGradesPartialUpdate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async studentGradesRetrieve(
			id: string,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesRetrieve(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['StudentGradesApi.studentGradesRetrieve']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {StudentGrade} studentGrade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async studentGradesUpdate(
			id: string,
			studentGrade: StudentGrade,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentGrade>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.studentGradesUpdate(
				id,
				studentGrade,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['StudentGradesApi.studentGradesUpdate']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * StudentGradesApi - factory interface
 *
 * @export
 */
export const StudentGradesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = StudentGradesApiFp(configuration)
	return {
		/**
		 * @param {StudentGrade} studentGrade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesCreate(
			studentGrade: StudentGrade,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<StudentGrade> {
			return localVarFp
				.studentGradesCreate(studentGrade, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesDestroy(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp
				.studentGradesDestroy(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<StudentGrade>> {
			return localVarFp.studentGradesList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {PatchedStudentGrade} [patchedStudentGrade]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesPartialUpdate(
			id: string,
			patchedStudentGrade?: PatchedStudentGrade,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<StudentGrade> {
			return localVarFp
				.studentGradesPartialUpdate(id, patchedStudentGrade, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesRetrieve(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StudentGrade> {
			return localVarFp
				.studentGradesRetrieve(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {string} id A UUID string identifying this student grade.
		 * @param {StudentGrade} studentGrade
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		studentGradesUpdate(
			id: string,
			studentGrade: StudentGrade,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<StudentGrade> {
			return localVarFp
				.studentGradesUpdate(id, studentGrade, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * StudentGradesApi - object-oriented interface
 *
 * @class StudentGradesApi
 * @extends {BaseAPI}
 * @export
 */
export class StudentGradesApi extends BaseAPI {
	/**
	 * @memberof StudentGradesApi
	 * @param {StudentGrade} studentGrade
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public studentGradesCreate(studentGrade: StudentGrade, options?: RawAxiosRequestConfig) {
		return StudentGradesApiFp(this.configuration)
			.studentGradesCreate(studentGrade, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof StudentGradesApi
	 * @param {string} id A UUID string identifying this student grade.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public studentGradesDestroy(id: string, options?: RawAxiosRequestConfig) {
		return StudentGradesApiFp(this.configuration)
			.studentGradesDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof StudentGradesApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public studentGradesList(options?: RawAxiosRequestConfig) {
		return StudentGradesApiFp(this.configuration)
			.studentGradesList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof StudentGradesApi
	 * @param {string} id A UUID string identifying this student grade.
	 * @param {PatchedStudentGrade} [patchedStudentGrade]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public studentGradesPartialUpdate(
		id: string,
		patchedStudentGrade?: PatchedStudentGrade,
		options?: RawAxiosRequestConfig,
	) {
		return StudentGradesApiFp(this.configuration)
			.studentGradesPartialUpdate(id, patchedStudentGrade, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof StudentGradesApi
	 * @param {string} id A UUID string identifying this student grade.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public studentGradesRetrieve(id: string, options?: RawAxiosRequestConfig) {
		return StudentGradesApiFp(this.configuration)
			.studentGradesRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof StudentGradesApi
	 * @param {string} id A UUID string identifying this student grade.
	 * @param {StudentGrade} studentGrade
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public studentGradesUpdate(
		id: string,
		studentGrade: StudentGrade,
		options?: RawAxiosRequestConfig,
	) {
		return StudentGradesApiFp(this.configuration)
			.studentGradesUpdate(id, studentGrade, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * UsersApi - axios parameter creator
 *
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {User} user
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersCreate: async (user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'user' is not null or undefined
			assertParamExists('usersCreate', 'user', user)
			const localVarPath = `/users/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				user,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('usersDestroy', 'id', id)
			const localVarPath = `/users/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/users/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {PatchedUser} [patchedUser]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPartialUpdate: async (
			id: number,
			patchedUser?: PatchedUser,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('usersPartialUpdate', 'id', id)
			const localVarPath = `/users/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedUser,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersRetrieve: async (
			id: number,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('usersRetrieve', 'id', id)
			const localVarPath = `/users/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {User} user
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersUpdate: async (
			id: number,
			user: User,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('usersUpdate', 'id', id)
			// verify required parameter 'user' is not null or undefined
			assertParamExists('usersUpdate', 'user', user)
			const localVarPath = `/users/{id}/`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication CsrfExemptSessionAuthentication required

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				user,
				localVarRequestOptions,
				configuration,
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * UsersApi - functional programming interface
 *
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
	return {
		/**
		 * @param {User} user
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async usersCreate(
			user: User,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(user, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['UsersApi.usersCreate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async usersDestroy(
			id: number,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.usersDestroy(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['UsersApi.usersDestroy']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async usersList(
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['UsersApi.usersList']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {PatchedUser} [patchedUser]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async usersPartialUpdate(
			id: number,
			patchedUser?: PatchedUser,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(
				id,
				patchedUser,
				options,
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['UsersApi.usersPartialUpdate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async usersRetrieve(
			id: number,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(id, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['UsersApi.usersRetrieve']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {User} user
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async usersUpdate(
			id: number,
			user: User,
			options?: RawAxiosRequestConfig,
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, user, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['UsersApi.usersUpdate']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * UsersApi - factory interface
 *
 * @export
 */
export const UsersApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = UsersApiFp(configuration)
	return {
		/**
		 * @param {User} user
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersCreate(user: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
			return localVarFp.usersCreate(user, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
			return localVarFp.usersDestroy(id, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersList(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
			return localVarFp.usersList(options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {PatchedUser} [patchedUser]
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPartialUpdate(
			id: number,
			patchedUser?: PatchedUser,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<User> {
			return localVarFp
				.usersPartialUpdate(id, patchedUser, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<User> {
			return localVarFp.usersRetrieve(id, options).then((request) => request(axios, basePath))
		},
		/**
		 * @param {number} id A unique integer value identifying this user.
		 * @param {User} user
		 * @param {any} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersUpdate(id: number, user: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
			return localVarFp.usersUpdate(id, user, options).then((request) => request(axios, basePath))
		},
	}
}

/**
 * UsersApi - object-oriented interface
 *
 * @class UsersApi
 * @extends {BaseAPI}
 * @export
 */
export class UsersApi extends BaseAPI {
	/**
	 * @memberof UsersApi
	 * @param {User} user
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public usersCreate(user: User, options?: RawAxiosRequestConfig) {
		return UsersApiFp(this.configuration)
			.usersCreate(user, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof UsersApi
	 * @param {number} id A unique integer value identifying this user.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public usersDestroy(id: number, options?: RawAxiosRequestConfig) {
		return UsersApiFp(this.configuration)
			.usersDestroy(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof UsersApi
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public usersList(options?: RawAxiosRequestConfig) {
		return UsersApiFp(this.configuration)
			.usersList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof UsersApi
	 * @param {number} id A unique integer value identifying this user.
	 * @param {PatchedUser} [patchedUser]
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public usersPartialUpdate(
		id: number,
		patchedUser?: PatchedUser,
		options?: RawAxiosRequestConfig,
	) {
		return UsersApiFp(this.configuration)
			.usersPartialUpdate(id, patchedUser, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof UsersApi
	 * @param {number} id A unique integer value identifying this user.
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public usersRetrieve(id: number, options?: RawAxiosRequestConfig) {
		return UsersApiFp(this.configuration)
			.usersRetrieve(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * @memberof UsersApi
	 * @param {number} id A unique integer value identifying this user.
	 * @param {User} user
	 * @param {any} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public usersUpdate(id: number, user: User, options?: RawAxiosRequestConfig) {
		return UsersApiFp(this.configuration)
			.usersUpdate(id, user, options)
			.then((request) => request(this.axios, this.basePath))
	}
}
